<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from gcc.texi on 30 July 1999 -->

<TITLE>Using and Porting GNU CC - RTL Representation</TITLE>
<link href="gcc_16.html" rel=Next>
<link href="gcc_14.html" rel=Previous>
<link href="gcc_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="gcc_1.html">first</A>, <A HREF="gcc_14.html">previous</A>, <A HREF="gcc_16.html">next</A>, <A HREF="gcc_24.html">last</A> section, <A HREF="gcc_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC149" HREF="gcc_toc.html#TOC149">RTL Representation</A></H1>
<P>
<A NAME="IDX699"></A>
<A NAME="IDX700"></A>
<A NAME="IDX701"></A>

</P>
<P>
Most of the work of the compiler is done on an intermediate representation
called register transfer language.  In this language, the instructions to be
output are described, pretty much one by one, in an algebraic form that
describes what the instruction does.

</P>
<P>
RTL is inspired by Lisp lists.  It has both an internal form, made up of
structures that point at other structures, and a textual form that is used
in the machine description and in printed debugging dumps.  The textual
form uses nested parentheses to indicate the pointers in the internal form.

</P>

<UL>
<LI><A HREF="gcc_15.html#SEC150">RTL Objects</A>: Expressions vs vectors vs strings vs integers.
<LI><A HREF="gcc_15.html#SEC151">RTL Classes</A>: Categories of RTL expresion objects, and their structure.
<LI><A HREF="gcc_15.html#SEC152">Accessors</A>: Macros to access expression operands or vector elts.
<LI><A HREF="gcc_15.html#SEC153">Flags</A>: Other flags in an RTL expression.
<LI><A HREF="gcc_15.html#SEC154">Machine Modes</A>: Describing the size and format of a datum.
<LI><A HREF="gcc_15.html#SEC155">Constants</A>: Expressions with constant values.
<LI><A HREF="gcc_15.html#SEC156">Regs and Memory</A>: Expressions representing register contents or memory.
<LI><A HREF="gcc_15.html#SEC157">Arithmetic</A>: Expressions representing arithmetic on other expressions.
<LI><A HREF="gcc_15.html#SEC158">Comparisons</A>: Expressions representing comparison of expressions.
<LI><A HREF="gcc_15.html#SEC159">Bit Fields</A>: Expressions representing bitfields in memory or reg.
<LI><A HREF="gcc_15.html#SEC160">Conversions</A>: Extending, truncating, floating or fixing.
<LI><A HREF="gcc_15.html#SEC161">RTL Declarations</A>: Declaring volatility, constancy, etc.
<LI><A HREF="gcc_15.html#SEC162">Side Effects</A>: Expressions for storing in registers, etc.
<LI><A HREF="gcc_15.html#SEC163">Incdec</A>: Embedded side-effects for autoincrement addressing.
<LI><A HREF="gcc_15.html#SEC164">Assembler</A>: Representing <CODE>asm</CODE> with operands.
<LI><A HREF="gcc_15.html#SEC165">Insns</A>: Expression types for entire insns.
<LI><A HREF="gcc_15.html#SEC166">Calls</A>: RTL representation of function call insns.
<LI><A HREF="gcc_15.html#SEC167">Sharing</A>: Some expressions are unique; others *must* be copied.
<LI><A HREF="gcc_15.html#SEC168">Reading RTL</A>: Reading textual RTL from a file.
</UL>



<H2><A NAME="SEC150" HREF="gcc_toc.html#TOC150">RTL Object Types</A></H2>
<P>
<A NAME="IDX702"></A>

</P>
<P>
<A NAME="IDX703"></A>
<A NAME="IDX704"></A>
<A NAME="IDX705"></A>
<A NAME="IDX706"></A>
<A NAME="IDX707"></A>
RTL uses five kinds of objects: expressions, integers, wide integers,
strings and vectors.  Expressions are the most important ones.  An RTL
expression ("RTX", for short) is a C structure, but it is usually
referred to with a pointer; a type that is given the typedef name
<CODE>rtx</CODE>.

</P>
<P>
An integer is simply an <CODE>int</CODE>; their written form uses decimal digits.
A wide integer is an integral object whose type is <CODE>HOST_WIDE_INT</CODE>
(see section <A HREF="gcc_18.html#SEC251">The Configuration File</A>); their written form uses decimal digits.

</P>
<P>
A string is a sequence of characters.  In core it is represented as a
<CODE>char *</CODE> in usual C fashion, and it is written in C syntax as well.
However, strings in RTL may never be null.  If you write an empty string in
a machine description, it is represented in core as a null pointer rather
than as a pointer to a null character.  In certain contexts, these null
pointers instead of strings are valid.  Within RTL code, strings are most
commonly found inside <CODE>symbol_ref</CODE> expressions, but they appear in
other contexts in the RTL expressions that make up machine descriptions.  

</P>
<P>
A vector contains an arbitrary number of pointers to expressions.  The
number of elements in the vector is explicitly present in the vector.
The written form of a vector consists of square brackets
(<SAMP>`[...]'</SAMP>) surrounding the elements, in sequence and with
whitespace separating them.  Vectors of length zero are not created;
null pointers are used instead.

</P>
<P>
<A NAME="IDX708"></A>
<A NAME="IDX709"></A>
<A NAME="IDX710"></A>
<A NAME="IDX711"></A>
Expressions are classified by <STRONG>expression codes</STRONG> (also called RTX
codes).  The expression code is a name defined in <TT>`rtl.def'</TT>, which is
also (in upper case) a C enumeration constant.  The possible expression
codes and their meanings are machine-independent.  The code of an RTX can
be extracted with the macro <CODE>GET_CODE (<VAR>x</VAR>)</CODE> and altered with
<CODE>PUT_CODE (<VAR>x</VAR>, <VAR>newcode</VAR>)</CODE>.

</P>
<P>
The expression code determines how many operands the expression contains,
and what kinds of objects they are.  In RTL, unlike Lisp, you cannot tell
by looking at an operand what kind of object it is.  Instead, you must know
from its context--from the expression code of the containing expression.
For example, in an expression of code <CODE>subreg</CODE>, the first operand is
to be regarded as an expression and the second operand as an integer.  In
an expression of code <CODE>plus</CODE>, there are two operands, both of which
are to be regarded as expressions.  In a <CODE>symbol_ref</CODE> expression,
there is one operand, which is to be regarded as a string.

</P>
<P>
Expressions are written as parentheses containing the name of the
expression type, its flags and machine mode if any, and then the operands
of the expression (separated by spaces).

</P>
<P>
Expression code names in the <SAMP>`md'</SAMP> file are written in lower case,
but when they appear in C code they are written in upper case.  In this
manual, they are shown as follows: <CODE>const_int</CODE>.

</P>
<P>
<A NAME="IDX712"></A>
<A NAME="IDX713"></A>
In a few contexts a null pointer is valid where an expression is normally
wanted.  The written form of this is <CODE>(nil)</CODE>.

</P>


<H2><A NAME="SEC151" HREF="gcc_toc.html#TOC151">RTL Classes and Formats</A></H2>
<P>
<A NAME="IDX714"></A>
<A NAME="IDX715"></A>
<A NAME="IDX716"></A>
<A NAME="IDX717"></A>

</P>
<P>
The various expression codes are divided into several <STRONG>classes</STRONG>,
which are represented by single characters.  You can determine the class
of an RTX code with the macro <CODE>GET_RTX_CLASS (<VAR>code</VAR>)</CODE>.
Currently, <TT>`rtx.def'</TT> defines these classes:

</P>
<DL COMPACT>

<DT><CODE>o</CODE>
<DD>
An RTX code that represents an actual object, such as a register
(<CODE>REG</CODE>) or a memory location (<CODE>MEM</CODE>, <CODE>SYMBOL_REF</CODE>).
Constants and basic transforms on objects (<CODE>ADDRESSOF</CODE>,
<CODE>HIGH</CODE>, <CODE>LO_SUM</CODE>) are also included.  Note that <CODE>SUBREG</CODE>
and <CODE>STRICT_LOW_PART</CODE> are not in this class, but in class <CODE>x</CODE>.

<DT><CODE>&#60;</CODE>
<DD>
An RTX code for a comparison, such as <CODE>NE</CODE> or <CODE>LT</CODE>.

<DT><CODE>1</CODE>
<DD>
An RTX code for a unary arithmetic operation, such as <CODE>NEG</CODE>,
<CODE>NOT</CODE>, or <CODE>ABS</CODE>.  This category also includes value extension
(sign or zero) and conversions between integer and floating point.

<DT><CODE>c</CODE>
<DD>
An RTX code for a commutative binary operation, such as <CODE>PLUS</CODE> or
<CODE>AND</CODE>.  <CODE>NE</CODE> and <CODE>EQ</CODE> are comparisons, so they have class
<CODE>&#60;</CODE>.

<DT><CODE>2</CODE>
<DD>
An RTX code for a non-commutative binary operation, such as <CODE>MINUS</CODE>,
<CODE>DIV</CODE>, or <CODE>ASHIFTRT</CODE>.

<DT><CODE>b</CODE>
<DD>
An RTX code for a bitfield operation.  Currently only
<CODE>ZERO_EXTRACT</CODE> and <CODE>SIGN_EXTRACT</CODE>.  These have three inputs
and are lvalues (so they can be used for insertion as well).  See section <A HREF="gcc_15.html#SEC159">Bit Fields</A>.

<DT><CODE>3</CODE>
<DD>
An RTX code for other three input operations.  Currently only
<CODE>IF_THEN_ELSE</CODE>.

<DT><CODE>i</CODE>
<DD>
An RTX code for an entire instruction:  <CODE>INSN</CODE>, <CODE>JUMP_INSN</CODE>, and
<CODE>CALL_INSN</CODE>. See section <A HREF="gcc_15.html#SEC165">Insns</A>.

<DT><CODE>m</CODE>
<DD>
An RTX code for something that matches in insns, such as
<CODE>MATCH_DUP</CODE>.  These only occur in machine descriptions.

<DT><CODE>x</CODE>
<DD>
All other RTX codes.  This category includes the remaining codes used
only in machine descriptions (<CODE>DEFINE_*</CODE>, etc.).  It also includes
all the codes describing side effects (<CODE>SET</CODE>, <CODE>USE</CODE>,
<CODE>CLOBBER</CODE>, etc.) and the non-insns that may appear on an insn
chain, such as <CODE>NOTE</CODE>, <CODE>BARRIER</CODE>, and <CODE>CODE_LABEL</CODE>.
</DL>

<P>
<A NAME="IDX718"></A>
For each expression type <TT>`rtl.def'</TT> specifies the number of
contained objects and their kinds, with four possibilities: <SAMP>`e'</SAMP> for
expression (actually a pointer to an expression), <SAMP>`i'</SAMP> for integer,
<SAMP>`w'</SAMP> for wide integer, <SAMP>`s'</SAMP> for string, and <SAMP>`E'</SAMP> for vector
of expressions.  The sequence of letters for an expression code is
called its <STRONG>format</STRONG>.  For example, the format of <CODE>subreg</CODE> is
<SAMP>`ei'</SAMP>.
</P>
<P>
<A NAME="IDX719"></A>
A few other format characters are used occasionally:

</P>
<DL COMPACT>

<DT><CODE>u</CODE>
<DD>
<SAMP>`u'</SAMP> is equivalent to <SAMP>`e'</SAMP> except that it is printed differently
in debugging dumps.  It is used for pointers to insns.

<DT><CODE>n</CODE>
<DD>
<SAMP>`n'</SAMP> is equivalent to <SAMP>`i'</SAMP> except that it is printed differently
in debugging dumps.  It is used for the line number or code number of a
<CODE>note</CODE> insn.

<DT><CODE>S</CODE>
<DD>
<SAMP>`S'</SAMP> indicates a string which is optional.  In the RTL objects in
core, <SAMP>`S'</SAMP> is equivalent to <SAMP>`s'</SAMP>, but when the object is read,
from an <SAMP>`md'</SAMP> file, the string value of this operand may be omitted.
An omitted string is taken to be the null string.

<DT><CODE>V</CODE>
<DD>
<SAMP>`V'</SAMP> indicates a vector which is optional.  In the RTL objects in
core, <SAMP>`V'</SAMP> is equivalent to <SAMP>`E'</SAMP>, but when the object is read
from an <SAMP>`md'</SAMP> file, the vector value of this operand may be omitted.
An omitted vector is effectively the same as a vector of no elements.

<DT><CODE>0</CODE>
<DD>
<SAMP>`0'</SAMP> means a slot whose contents do not fit any normal category.
<SAMP>`0'</SAMP> slots are not printed at all in dumps, and are often used in
special ways by small parts of the compiler.
</DL>

<P>
There are macros to get the number of operands and the format
of an expression code:

</P>
<DL COMPACT>

<DT><CODE>GET_RTX_LENGTH (<VAR>code</VAR>)</CODE>
<DD>
<A NAME="IDX720"></A>
 
Number of operands of an RTX of code <VAR>code</VAR>.

<A NAME="IDX721"></A>
<DT><CODE>GET_RTX_FORMAT (<VAR>code</VAR>)</CODE>
<DD>
The format of an RTX of code <VAR>code</VAR>, as a C string.
</DL>

<P>
Some classes of RTX codes always have the same format.  For example, it
is safe to assume that all comparison operations have format <CODE>ee</CODE>.

</P>
<DL COMPACT>

<DT><CODE>1</CODE>
<DD>
All codes of this class have format <CODE>e</CODE>.

<DT><CODE>&#60;</CODE>
<DD>
<DT><CODE>c</CODE>
<DD>
<DT><CODE>2</CODE>
<DD>
All codes of these classes have format <CODE>ee</CODE>.

<DT><CODE>b</CODE>
<DD>
<DT><CODE>3</CODE>
<DD>
All codes of these classes have format <CODE>eee</CODE>.

<DT><CODE>i</CODE>
<DD>
All codes of this class have formats that begin with <CODE>iuueiee</CODE>.
See section <A HREF="gcc_15.html#SEC165">Insns</A>.  Note that not all RTL objects linked onto an insn chain
are of class <CODE>i</CODE>.

<DT><CODE>o</CODE>
<DD>
<DT><CODE>m</CODE>
<DD>
<DT><CODE>x</CODE>
<DD>
You can make no assumptions about the format of these codes.
</DL>



<H2><A NAME="SEC152" HREF="gcc_toc.html#TOC152">Access to Operands</A></H2>
<P>
<A NAME="IDX722"></A>
<A NAME="IDX723"></A>
<A NAME="IDX724"></A>

</P>
<P>
<A NAME="IDX725"></A>
<A NAME="IDX726"></A>
<A NAME="IDX727"></A>
<A NAME="IDX728"></A>
Operands of expressions are accessed using the macros <CODE>XEXP</CODE>,
<CODE>XINT</CODE>, <CODE>XWINT</CODE> and <CODE>XSTR</CODE>.  Each of these macros takes
two arguments: an expression-pointer (RTX) and an operand number
(counting from zero).  Thus,
</P>

<PRE>
XEXP (<VAR>x</VAR>, 2)
</PRE>

<P>
accesses operand 2 of expression <VAR>x</VAR>, as an expression.

</P>

<PRE>
XINT (<VAR>x</VAR>, 2)
</PRE>

<P>
accesses the same operand as an integer.  <CODE>XSTR</CODE>, used in the same
fashion, would access it as a string.

</P>
<P>
Any operand can be accessed as an integer, as an expression or as a string.
You must choose the correct method of access for the kind of value actually
stored in the operand.  You would do this based on the expression code of
the containing expression.  That is also how you would know how many
operands there are.

</P>
<P>
For example, if <VAR>x</VAR> is a <CODE>subreg</CODE> expression, you know that it has
two operands which can be correctly accessed as <CODE>XEXP (<VAR>x</VAR>, 0)</CODE>
and <CODE>XINT (<VAR>x</VAR>, 1)</CODE>.  If you did <CODE>XINT (<VAR>x</VAR>, 0)</CODE>, you
would get the address of the expression operand but cast as an integer;
that might occasionally be useful, but it would be cleaner to write
<CODE>(int) XEXP (<VAR>x</VAR>, 0)</CODE>.  <CODE>XEXP (<VAR>x</VAR>, 1)</CODE> would also
compile without error, and would return the second, integer operand cast as
an expression pointer, which would probably result in a crash when
accessed.  Nothing stops you from writing <CODE>XEXP (<VAR>x</VAR>, 28)</CODE> either,
but this will access memory past the end of the expression with
unpredictable results.
</P>
<P>
Access to operands which are vectors is more complicated.  You can use the
macro <CODE>XVEC</CODE> to get the vector-pointer itself, or the macros
<CODE>XVECEXP</CODE> and <CODE>XVECLEN</CODE> to access the elements and length of a
vector.

</P>
<DL COMPACT>

<DT><CODE>XVEC (<VAR>exp</VAR>, <VAR>idx</VAR>)</CODE>
<DD>
<A NAME="IDX729"></A>
 
Access the vector-pointer which is operand number <VAR>idx</VAR> in <VAR>exp</VAR>.

<A NAME="IDX730"></A>
<DT><CODE>XVECLEN (<VAR>exp</VAR>, <VAR>idx</VAR>)</CODE>
<DD>
Access the length (number of elements) in the vector which is
in operand number <VAR>idx</VAR> in <VAR>exp</VAR>.  This value is an <CODE>int</CODE>.

<A NAME="IDX731"></A>
<DT><CODE>XVECEXP (<VAR>exp</VAR>, <VAR>idx</VAR>, <VAR>eltnum</VAR>)</CODE>
<DD>
Access element number <VAR>eltnum</VAR> in the vector which is
in operand number <VAR>idx</VAR> in <VAR>exp</VAR>.  This value is an RTX.

It is up to you to make sure that <VAR>eltnum</VAR> is not negative
and is less than <CODE>XVECLEN (<VAR>exp</VAR>, <VAR>idx</VAR>)</CODE>.
</DL>

<P>
All the macros defined in this section expand into lvalues and therefore
can be used to assign the operands, lengths and vector elements as well as
to access them.

</P>


<H2><A NAME="SEC153" HREF="gcc_toc.html#TOC153">Flags in an RTL Expression</A></H2>
<P>
<A NAME="IDX732"></A>

</P>
<P>
RTL expressions contain several flags (one-bit bitfields) and other
values that are used in certain types of expression.  Most often they
are accessed with the following macros:

</P>
<DL COMPACT>

<DT><CODE>MEM_VOLATILE_P (<VAR>x</VAR>)</CODE>
<DD>
<A NAME="IDX733"></A>
 <A NAME="IDX734"></A>
 <A NAME="IDX735"></A>
 <A NAME="IDX736"></A>
 
In <CODE>mem</CODE> expressions, nonzero for volatile memory references.
Stored in the <CODE>volatil</CODE> field and printed as <SAMP>`/v'</SAMP>.

<A NAME="IDX737"></A>
<A NAME="IDX738"></A>
<A NAME="IDX739"></A>
<A NAME="IDX740"></A>
<DT><CODE>MEM_IN_STRUCT_P (<VAR>x</VAR>)</CODE>
<DD>
In <CODE>mem</CODE> expressions, nonzero for reference to an entire structure,
union or array, or to a component of one.  Zero for references to a
scalar variable or through a pointer to a scalar.  Stored in the
<CODE>in_struct</CODE> field and printed as <SAMP>`/s'</SAMP>.  If both this flag and
MEM_SCALAR_P are clear, then we don't know whether this MEM is in a
structure or not.  Both flags should never be simultaneously set.

<A NAME="IDX741"></A>
<A NAME="IDX742"></A>
<A NAME="IDX743"></A>
<A NAME="IDX744"></A>
<DT><CODE>MEM_SCALAR_P (<VAR>x</VAR>)</CODE>
<DD>
In <CODE>mem</CODE> expressions, nonzero for reference to a scalar known not
to be a member of a structure, union, or array.  Zero for such
references and for indirections through pointers, even pointers pointing
to scalar types.  If both this flag and MEM_STRUCT_P are clear, then we
don't know whether this MEM is in a structure or not.  Both flags should
never be simultaneously set.

<A NAME="IDX745"></A>
<DT><CODE>MEM_ALIAS_SET (<VAR>x</VAR>)</CODE>
<DD>
In <CODE>mem</CODE> expressions, the alias set to which <VAR>x</VAR> belongs.  If
zero, <VAR>x</VAR> is not in any alias set, and may alias anything.  If
nonzero, <VAR>x</VAR> may only alias objects in the same alias set.  This
value is set (in a language-specific manner) by the front-end.  This
field is not a bit-field; it is in an integer, found as the second
argument to the <CODE>mem</CODE>.

<A NAME="IDX746"></A>
<A NAME="IDX747"></A>
<A NAME="IDX748"></A>
<DT><CODE>REG_LOOP_TEST_P</CODE>
<DD>
In <CODE>reg</CODE> expressions, nonzero if this register's entire life is
contained in the exit test code for some loop.  Stored in the
<CODE>in_struct</CODE> field and printed as <SAMP>`/s'</SAMP>.

<A NAME="IDX749"></A>
<A NAME="IDX750"></A>
<A NAME="IDX751"></A>
<DT><CODE>REG_USERVAR_P (<VAR>x</VAR>)</CODE>
<DD>
In a <CODE>reg</CODE>, nonzero if it corresponds to a variable present in
the user's source code.  Zero for temporaries generated internally by
the compiler.  Stored in the <CODE>volatil</CODE> field and printed as
<SAMP>`/v'</SAMP>.

<A NAME="IDX752"></A>
<A NAME="IDX753"></A>
<A NAME="IDX754"></A>
<A NAME="IDX755"></A>
<DT><CODE>REG_FUNCTION_VALUE_P (<VAR>x</VAR>)</CODE>
<DD>
Nonzero in a <CODE>reg</CODE> if it is the place in which this function's
value is going to be returned.  (This happens only in a hard
register.)  Stored in the <CODE>integrated</CODE> field and printed as
<SAMP>`/i'</SAMP>.

The same hard register may be used also for collecting the values of
functions called by this one, but <CODE>REG_FUNCTION_VALUE_P</CODE> is zero
in this kind of use.

<A NAME="IDX756"></A>
<A NAME="IDX757"></A>
<A NAME="IDX758"></A>
<DT><CODE>SUBREG_PROMOTED_VAR_P</CODE>
<DD>
Nonzero in a <CODE>subreg</CODE> if it was made when accessing an object that
was promoted to a wider mode in accord with the <CODE>PROMOTED_MODE</CODE> machine
description macro (see section <A HREF="gcc_17.html#SEC202">Storage Layout</A>).  In this case, the mode of
the <CODE>subreg</CODE> is the declared mode of the object and the mode of
<CODE>SUBREG_REG</CODE> is the mode of the register that holds the object.
Promoted variables are always either sign- or zero-extended to the wider
mode on every assignment.  Stored in the <CODE>in_struct</CODE> field and
printed as <SAMP>`/s'</SAMP>.

<A NAME="IDX759"></A>
<A NAME="IDX760"></A>
<A NAME="IDX761"></A>
<DT><CODE>SUBREG_PROMOTED_UNSIGNED_P</CODE>
<DD>
Nonzero in a <CODE>subreg</CODE> that has <CODE>SUBREG_PROMOTED_VAR_P</CODE> nonzero
if the object being referenced is kept zero-extended and zero if it
is kept sign-extended.  Stored in the <CODE>unchanging</CODE> field and
printed as <SAMP>`/u'</SAMP>.

<A NAME="IDX762"></A>
<A NAME="IDX763"></A>
<A NAME="IDX764"></A>
<A NAME="IDX765"></A>
<A NAME="IDX766"></A>
<DT><CODE>RTX_UNCHANGING_P (<VAR>x</VAR>)</CODE>
<DD>
Nonzero in a <CODE>reg</CODE> or <CODE>mem</CODE> if the value is not changed.
(This flag is not set for memory references via pointers to constants.
Such pointers only guarantee that the object will not be changed
explicitly by the current function.  The object might be changed by
other functions or by aliasing.)  Stored in the
<CODE>unchanging</CODE> field and printed as <SAMP>`/u'</SAMP>.

<A NAME="IDX767"></A>
<A NAME="IDX768"></A>
<DT><CODE>RTX_INTEGRATED_P (<VAR>insn</VAR>)</CODE>
<DD>
Nonzero in an insn if it resulted from an in-line function call.
Stored in the <CODE>integrated</CODE> field and printed as <SAMP>`/i'</SAMP>.

<A NAME="IDX769"></A>
<DT><CODE>RTX_FRAME_RELATED_P (<VAR>x</VAR>)</CODE>
<DD>
Nonzero in an insn or expression which is part of a function
prologue and sets the stack pointer, sets the frame pointer, or saves a 
register. This flag is required for exception handling support
on targets with RTL prologues.

<A NAME="IDX770"></A>
<A NAME="IDX771"></A>
<DT><CODE>SYMBOL_REF_USED (<VAR>x</VAR>)</CODE>
<DD>
In a <CODE>symbol_ref</CODE>, indicates that <VAR>x</VAR> has been used.  This is
normally only used to ensure that <VAR>x</VAR> is only declared external
once.  Stored in the <CODE>used</CODE> field.

<A NAME="IDX772"></A>
<A NAME="IDX773"></A>
<A NAME="IDX774"></A>
<DT><CODE>SYMBOL_REF_FLAG (<VAR>x</VAR>)</CODE>
<DD>
In a <CODE>symbol_ref</CODE>, this is used as a flag for machine-specific purposes.
Stored in the <CODE>volatil</CODE> field and printed as <SAMP>`/v'</SAMP>.

<A NAME="IDX775"></A>
<A NAME="IDX776"></A>
<A NAME="IDX777"></A>
<DT><CODE>LABEL_OUTSIDE_LOOP_P</CODE>
<DD>
In <CODE>label_ref</CODE> expressions, nonzero if this is a reference to a
label that is outside the innermost loop containing the reference to the
label.  Stored in the <CODE>in_struct</CODE> field and printed as <SAMP>`/s'</SAMP>.

<A NAME="IDX778"></A>
<A NAME="IDX779"></A>
<DT><CODE>INSN_DELETED_P (<VAR>insn</VAR>)</CODE>
<DD>
In an insn, nonzero if the insn has been deleted.  Stored in the
<CODE>volatil</CODE> field and printed as <SAMP>`/v'</SAMP>.

<A NAME="IDX780"></A>
<A NAME="IDX781"></A>
<A NAME="IDX782"></A>
<DT><CODE>INSN_ANNULLED_BRANCH_P (<VAR>insn</VAR>)</CODE>
<DD>
In an <CODE>insn</CODE> in the delay slot of a branch insn, indicates that an
annulling branch should be used.  See the discussion under
<CODE>sequence</CODE> below.  Stored in the <CODE>unchanging</CODE> field and printed
as <SAMP>`/u'</SAMP>.

<A NAME="IDX783"></A>
<A NAME="IDX784"></A>
<A NAME="IDX785"></A>
<A NAME="IDX786"></A>
<DT><CODE>INSN_FROM_TARGET_P (<VAR>insn</VAR>)</CODE>
<DD>
In an <CODE>insn</CODE> in a delay slot of a branch, indicates that the insn
is from the target of the branch.  If the branch insn has
<CODE>INSN_ANNULLED_BRANCH_P</CODE> set, this insn will only be executed if
the branch is taken.  For annulled branches with
<CODE>INSN_FROM_TARGET_P</CODE> clear, the insn will be executed only if the
branch is not taken.  When <CODE>INSN_ANNULLED_BRANCH_P</CODE> is not set,
this insn will always be executed.  Stored in the <CODE>in_struct</CODE>
field and printed as <SAMP>`/s'</SAMP>.

<A NAME="IDX787"></A>
<A NAME="IDX788"></A>
<A NAME="IDX789"></A>
<DT><CODE>CONSTANT_POOL_ADDRESS_P (<VAR>x</VAR>)</CODE>
<DD>
Nonzero in a <CODE>symbol_ref</CODE> if it refers to part of the current
function's "constants pool".  These are addresses close to the
beginning of the function, and GNU CC assumes they can be addressed
directly (perhaps with the help of base registers).  Stored in the
<CODE>unchanging</CODE> field and printed as <SAMP>`/u'</SAMP>.

<A NAME="IDX790"></A>
<A NAME="IDX791"></A>
<A NAME="IDX792"></A>
<DT><CODE>CONST_CALL_P (<VAR>x</VAR>)</CODE>
<DD>
In a <CODE>call_insn</CODE>, indicates that the insn represents a call to a const
function.  Stored in the <CODE>unchanging</CODE> field and printed as <SAMP>`/u'</SAMP>.

<A NAME="IDX793"></A>
<A NAME="IDX794"></A>
<A NAME="IDX795"></A>
<DT><CODE>LABEL_PRESERVE_P (<VAR>x</VAR>)</CODE>
<DD>
In a <CODE>code_label</CODE>, indicates that the label can never be deleted.
Labels referenced by a non-local goto will have this bit set.  Stored
in the <CODE>in_struct</CODE> field and printed as <SAMP>`/s'</SAMP>.

<A NAME="IDX796"></A>
<A NAME="IDX797"></A>
<A NAME="IDX798"></A>
<DT><CODE>SCHED_GROUP_P (<VAR>insn</VAR>)</CODE>
<DD>
During instruction scheduling, in an insn, indicates that the previous insn
must be scheduled together with this insn.  This is used to ensure that
certain groups of instructions will not be split up by the instruction
scheduling pass, for example, <CODE>use</CODE> insns before a <CODE>call_insn</CODE> may
not be separated from the <CODE>call_insn</CODE>.  Stored in the <CODE>in_struct</CODE>
field and printed as <SAMP>`/s'</SAMP>.
</DL>

<P>
These are the fields which the above macros refer to:

</P>
<DL COMPACT>

<DT><CODE>used</CODE>
<DD>
<A NAME="IDX799"></A>
 
Normally, this flag is used only momentarily, at the end of RTL
generation for a function, to count the number of times an expression
appears in insns.  Expressions that appear more than once are copied,
according to the rules for shared structure (see section <A HREF="gcc_15.html#SEC167">Structure Sharing Assumptions</A>).

In a <CODE>symbol_ref</CODE>, it indicates that an external declaration for
the symbol has already been written.

In a <CODE>reg</CODE>, it is used by the leaf register renumbering code to ensure
that each register is only renumbered once.

<A NAME="IDX800"></A>
<DT><CODE>volatil</CODE>
<DD>
This flag is used in <CODE>mem</CODE>, <CODE>symbol_ref</CODE> and <CODE>reg</CODE>
expressions and in insns.  In RTL dump files, it is printed as
<SAMP>`/v'</SAMP>.

<A NAME="IDX801"></A>
In a <CODE>mem</CODE> expression, it is 1 if the memory reference is volatile.
Volatile memory references may not be deleted, reordered or combined.

In a <CODE>symbol_ref</CODE> expression, it is used for machine-specific 
purposes.

In a <CODE>reg</CODE> expression, it is 1 if the value is a user-level variable.
0 indicates an internal compiler temporary.

In an insn, 1 means the insn has been deleted.

<A NAME="IDX802"></A>
<DT><CODE>in_struct</CODE>
<DD>
In <CODE>mem</CODE> expressions, it is 1 if the memory datum referred to is
all or part of a structure or array; 0 if it is (or might be) a scalar
variable.  A reference through a C pointer has 0 because the pointer
might point to a scalar variable.  This information allows the compiler
to determine something about possible cases of aliasing.

In an insn in the delay slot of a branch, 1 means that this insn is from
the target of the branch.

During instruction scheduling, in an insn, 1 means that this insn must be
scheduled as part of a group together with the previous insn.

In <CODE>reg</CODE> expressions, it is 1 if the register has its entire life
contained within the test expression of some loop.

In <CODE>subreg</CODE> expressions, 1 means that the <CODE>subreg</CODE> is accessing
an object that has had its mode promoted from a wider mode.

In <CODE>label_ref</CODE> expressions, 1 means that the referenced label is
outside the innermost loop containing the insn in which the <CODE>label_ref</CODE>
was found.

In <CODE>code_label</CODE> expressions, it is 1 if the label may never be deleted.
This is used for labels which are the target of non-local gotos.

In an RTL dump, this flag is represented as <SAMP>`/s'</SAMP>.

<A NAME="IDX803"></A>
<DT><CODE>unchanging</CODE>
<DD>
In <CODE>reg</CODE> and <CODE>mem</CODE> expressions, 1 means
that the value of the expression never changes.

In <CODE>subreg</CODE> expressions, it is 1 if the <CODE>subreg</CODE> references an
unsigned object whose mode has been promoted to a wider mode.

In an insn, 1 means that this is an annulling branch.

In a <CODE>symbol_ref</CODE> expression, 1 means that this symbol addresses
something in the per-function constants pool.

In a <CODE>call_insn</CODE>, 1 means that this instruction is a call to a
const function.

In an RTL dump, this flag is represented as <SAMP>`/u'</SAMP>.

<A NAME="IDX804"></A>
<DT><CODE>integrated</CODE>
<DD>
In some kinds of expressions, including insns, this flag means the
rtl was produced by procedure integration.

In a <CODE>reg</CODE> expression, this flag indicates the register
containing the value to be returned by the current function.  On
machines that pass parameters in registers, the same register number
may be used for parameters as well, but this flag is not set on such
uses.
</DL>



<H2><A NAME="SEC154" HREF="gcc_toc.html#TOC154">Machine Modes</A></H2>
<P>
<A NAME="IDX805"></A>

</P>
<P>
<A NAME="IDX806"></A>
A machine mode describes a size of data object and the representation used
for it.  In the C code, machine modes are represented by an enumeration
type, <CODE>enum machine_mode</CODE>, defined in <TT>`machmode.def'</TT>.  Each RTL
expression has room for a machine mode and so do certain kinds of tree
expressions (declarations and types, to be precise).

</P>
<P>
In debugging dumps and machine descriptions, the machine mode of an RTL
expression is written after the expression code with a colon to separate
them.  The letters <SAMP>`mode'</SAMP> which appear at the end of each machine mode
name are omitted.  For example, <CODE>(reg:SI 38)</CODE> is a <CODE>reg</CODE>
expression with machine mode <CODE>SImode</CODE>.  If the mode is
<CODE>VOIDmode</CODE>, it is not written at all.

</P>
<P>
Here is a table of machine modes.  The term "byte" below refers to an
object of <CODE>BITS_PER_UNIT</CODE> bits (see section <A HREF="gcc_17.html#SEC202">Storage Layout</A>).

</P>
<DL COMPACT>

<DT><CODE>QImode</CODE>
<DD>
<A NAME="IDX807"></A>
 
"Quarter-Integer" mode represents a single byte treated as an integer.

<A NAME="IDX808"></A>
<DT><CODE>HImode</CODE>
<DD>
"Half-Integer" mode represents a two-byte integer.

<A NAME="IDX809"></A>
<DT><CODE>PSImode</CODE>
<DD>
"Partial Single Integer" mode represents an integer which occupies
four bytes but which doesn't really use all four.  On some machines,
this is the right mode to use for pointers.

<A NAME="IDX810"></A>
<DT><CODE>SImode</CODE>
<DD>
"Single Integer" mode represents a four-byte integer.

<A NAME="IDX811"></A>
<DT><CODE>PDImode</CODE>
<DD>
"Partial Double Integer" mode represents an integer which occupies
eight bytes but which doesn't really use all eight.  On some machines,
this is the right mode to use for certain pointers.

<A NAME="IDX812"></A>
<DT><CODE>DImode</CODE>
<DD>
"Double Integer" mode represents an eight-byte integer.

<A NAME="IDX813"></A>
<DT><CODE>TImode</CODE>
<DD>
"Tetra Integer" (?) mode represents a sixteen-byte integer.

<A NAME="IDX814"></A>
<DT><CODE>SFmode</CODE>
<DD>
"Single Floating" mode represents a single-precision (four byte) floating
point number.

<A NAME="IDX815"></A>
<DT><CODE>DFmode</CODE>
<DD>
"Double Floating" mode represents a double-precision (eight byte) floating
point number.

<A NAME="IDX816"></A>
<DT><CODE>XFmode</CODE>
<DD>
"Extended Floating" mode represents a triple-precision (twelve byte)
floating point number.  This mode is used for IEEE extended floating
point.  On some systems not all bits within these bytes will actually
be used.

<A NAME="IDX817"></A>
<DT><CODE>TFmode</CODE>
<DD>
"Tetra Floating" mode represents a quadruple-precision (sixteen byte)
floating point number.

<A NAME="IDX818"></A>
<DT><CODE>CCmode</CODE>
<DD>
"Condition Code" mode represents the value of a condition code, which
is a machine-specific set of bits used to represent the result of a
comparison operation.  Other machine-specific modes may also be used for
the condition code.  These modes are not used on machines that use
<CODE>cc0</CODE> (see see section <A HREF="gcc_17.html#SEC228">Condition Code Status</A>).

<A NAME="IDX819"></A>
<DT><CODE>BLKmode</CODE>
<DD>
"Block" mode represents values that are aggregates to which none of
the other modes apply.  In RTL, only memory references can have this mode,
and only if they appear in string-move or vector instructions.  On machines
which have no such instructions, <CODE>BLKmode</CODE> will not appear in RTL.

<A NAME="IDX820"></A>
<DT><CODE>VOIDmode</CODE>
<DD>
Void mode means the absence of a mode or an unspecified mode.
For example, RTL expressions of code <CODE>const_int</CODE> have mode
<CODE>VOIDmode</CODE> because they can be taken to have whatever mode the context
requires.  In debugging dumps of RTL, <CODE>VOIDmode</CODE> is expressed by
the absence of any mode.

<A NAME="IDX821"></A>
<A NAME="IDX822"></A>
<A NAME="IDX823"></A>
<A NAME="IDX824"></A>
<DT><CODE>SCmode, DCmode, XCmode, TCmode</CODE>
<DD>
These modes stand for a complex number represented as a pair of floating
point values.  The floating point values are in <CODE>SFmode</CODE>,
<CODE>DFmode</CODE>, <CODE>XFmode</CODE>, and <CODE>TFmode</CODE>, respectively.

<A NAME="IDX825"></A>
<A NAME="IDX826"></A>
<A NAME="IDX827"></A>
<A NAME="IDX828"></A>
<A NAME="IDX829"></A>
<A NAME="IDX830"></A>
<DT><CODE>CQImode, CHImode, CSImode, CDImode, CTImode, COImode</CODE>
<DD>
These modes stand for a complex number represented as a pair of integer
values.  The integer values are in <CODE>QImode</CODE>, <CODE>HImode</CODE>,
<CODE>SImode</CODE>, <CODE>DImode</CODE>, <CODE>TImode</CODE>, and <CODE>OImode</CODE>,
respectively.
</DL>

<P>
The machine description defines <CODE>Pmode</CODE> as a C macro which expands
into the machine mode used for addresses.  Normally this is the mode
whose size is <CODE>BITS_PER_WORD</CODE>, <CODE>SImode</CODE> on 32-bit machines.

</P>
<P>
The only modes which a machine description <I>must</I> support are
<CODE>QImode</CODE>, and the modes corresponding to <CODE>BITS_PER_WORD</CODE>,
<CODE>FLOAT_TYPE_SIZE</CODE> and <CODE>DOUBLE_TYPE_SIZE</CODE>.
The compiler will attempt to use <CODE>DImode</CODE> for 8-byte structures and
unions, but this can be prevented by overriding the definition of
<CODE>MAX_FIXED_MODE_SIZE</CODE>.  Alternatively, you can have the compiler
use <CODE>TImode</CODE> for 16-byte structures and unions.  Likewise, you can
arrange for the C type <CODE>short int</CODE> to avoid using <CODE>HImode</CODE>.

</P>
<P>
<A NAME="IDX831"></A>
Very few explicit references to machine modes remain in the compiler and
these few references will soon be removed.  Instead, the machine modes
are divided into mode classes.  These are represented by the enumeration
type <CODE>enum mode_class</CODE> defined in <TT>`machmode.h'</TT>.  The possible
mode classes are:

</P>
<DL COMPACT>

<DT><CODE>MODE_INT</CODE>
<DD>
<A NAME="IDX832"></A>
 
Integer modes.  By default these are <CODE>QImode</CODE>, <CODE>HImode</CODE>,
<CODE>SImode</CODE>, <CODE>DImode</CODE>, and <CODE>TImode</CODE>.

<A NAME="IDX833"></A>
<DT><CODE>MODE_PARTIAL_INT</CODE>
<DD>
The "partial integer" modes, <CODE>PSImode</CODE> and <CODE>PDImode</CODE>.

<A NAME="IDX834"></A>
<DT><CODE>MODE_FLOAT</CODE>
<DD>
floating point modes.  By default these are <CODE>SFmode</CODE>, <CODE>DFmode</CODE>,
<CODE>XFmode</CODE> and <CODE>TFmode</CODE>.

<A NAME="IDX835"></A>
<DT><CODE>MODE_COMPLEX_INT</CODE>
<DD>
Complex integer modes.  (These are not currently implemented).

<A NAME="IDX836"></A>
<DT><CODE>MODE_COMPLEX_FLOAT</CODE>
<DD>
Complex floating point modes.  By default these are <CODE>SCmode</CODE>,
<CODE>DCmode</CODE>, <CODE>XCmode</CODE>, and <CODE>TCmode</CODE>.

<A NAME="IDX837"></A>
<DT><CODE>MODE_FUNCTION</CODE>
<DD>
Algol or Pascal function variables including a static chain.
(These are not currently implemented).

<A NAME="IDX838"></A>
<DT><CODE>MODE_CC</CODE>
<DD>
Modes representing condition code values.  These are <CODE>CCmode</CODE> plus
any modes listed in the <CODE>EXTRA_CC_MODES</CODE> macro.  See section <A HREF="gcc_16.html#SEC185">Defining Jump Instruction Patterns</A>,
also see section <A HREF="gcc_17.html#SEC228">Condition Code Status</A>.

<A NAME="IDX839"></A>
<DT><CODE>MODE_RANDOM</CODE>
<DD>
This is a catchall mode class for modes which don't fit into the above
classes.  Currently <CODE>VOIDmode</CODE> and <CODE>BLKmode</CODE> are in
<CODE>MODE_RANDOM</CODE>.
</DL>

<P>
Here are some C macros that relate to machine modes:

</P>
<DL COMPACT>

<DT><CODE>GET_MODE (<VAR>x</VAR>)</CODE>
<DD>
<A NAME="IDX840"></A>
 
Returns the machine mode of the RTX <VAR>x</VAR>.

<A NAME="IDX841"></A>
<DT><CODE>PUT_MODE (<VAR>x</VAR>, <VAR>newmode</VAR>)</CODE>
<DD>
Alters the machine mode of the RTX <VAR>x</VAR> to be <VAR>newmode</VAR>.

<A NAME="IDX842"></A>
<DT><CODE>NUM_MACHINE_MODES</CODE>
<DD>
Stands for the number of machine modes available on the target
machine.  This is one greater than the largest numeric value of any
machine mode.

<A NAME="IDX843"></A>
<DT><CODE>GET_MODE_NAME (<VAR>m</VAR>)</CODE>
<DD>
Returns the name of mode <VAR>m</VAR> as a string.

<A NAME="IDX844"></A>
<DT><CODE>GET_MODE_CLASS (<VAR>m</VAR>)</CODE>
<DD>
Returns the mode class of mode <VAR>m</VAR>.

<A NAME="IDX845"></A>
<DT><CODE>GET_MODE_WIDER_MODE (<VAR>m</VAR>)</CODE>
<DD>
Returns the next wider natural mode.  For example, the expression
<CODE>GET_MODE_WIDER_MODE (QImode)</CODE> returns <CODE>HImode</CODE>.

<A NAME="IDX846"></A>
<DT><CODE>GET_MODE_SIZE (<VAR>m</VAR>)</CODE>
<DD>
Returns the size in bytes of a datum of mode <VAR>m</VAR>.

<A NAME="IDX847"></A>
<DT><CODE>GET_MODE_BITSIZE (<VAR>m</VAR>)</CODE>
<DD>
Returns the size in bits of a datum of mode <VAR>m</VAR>.

<A NAME="IDX848"></A>
<DT><CODE>GET_MODE_MASK (<VAR>m</VAR>)</CODE>
<DD>
Returns a bitmask containing 1 for all bits in a word that fit within
mode <VAR>m</VAR>.  This macro can only be used for modes whose bitsize is
less than or equal to <CODE>HOST_BITS_PER_INT</CODE>.

<A NAME="IDX849"></A>
<DT><CODE>GET_MODE_ALIGNMENT (<VAR>m)</VAR>)</CODE>
<DD>
Return the required alignment, in bits, for an object of mode <VAR>m</VAR>.

<A NAME="IDX850"></A>
<DT><CODE>GET_MODE_UNIT_SIZE (<VAR>m</VAR>)</CODE>
<DD>
Returns the size in bytes of the subunits of a datum of mode <VAR>m</VAR>.
This is the same as <CODE>GET_MODE_SIZE</CODE> except in the case of complex
modes.  For them, the unit size is the size of the real or imaginary
part.

<A NAME="IDX851"></A>
<DT><CODE>GET_MODE_NUNITS (<VAR>m</VAR>)</CODE>
<DD>
Returns the number of units contained in a mode, i.e.,
<CODE>GET_MODE_SIZE</CODE> divided by <CODE>GET_MODE_UNIT_SIZE</CODE>.

<A NAME="IDX852"></A>
<DT><CODE>GET_CLASS_NARROWEST_MODE (<VAR>c</VAR>)</CODE>
<DD>
Returns the narrowest mode in mode class <VAR>c</VAR>.
</DL>

<P>
<A NAME="IDX853"></A>
<A NAME="IDX854"></A>
The global variables <CODE>byte_mode</CODE> and <CODE>word_mode</CODE> contain modes
whose classes are <CODE>MODE_INT</CODE> and whose bitsizes are either
<CODE>BITS_PER_UNIT</CODE> or <CODE>BITS_PER_WORD</CODE>, respectively.  On 32-bit
machines, these are <CODE>QImode</CODE> and <CODE>SImode</CODE>, respectively.

</P>


<H2><A NAME="SEC155" HREF="gcc_toc.html#TOC155">Constant Expression Types</A></H2>
<P>
<A NAME="IDX855"></A>
<A NAME="IDX856"></A>

</P>
<P>
The simplest RTL expressions are those that represent constant values.

</P>
<DL COMPACT>

<DT><CODE>(const_int <VAR>i</VAR>)</CODE>
<DD>
<A NAME="IDX857"></A>
 
This type of expression represents the integer value <VAR>i</VAR>.  <VAR>i</VAR>
is customarily accessed with the macro <CODE>INTVAL</CODE> as in
<CODE>INTVAL (<VAR>exp</VAR>)</CODE>, which is equivalent to <CODE>XWINT (<VAR>exp</VAR>, 0)</CODE>.

<A NAME="IDX858"></A>
<A NAME="IDX859"></A>
<A NAME="IDX860"></A>
<A NAME="IDX861"></A>
There is only one expression object for the integer value zero; it is
the value of the variable <CODE>const0_rtx</CODE>.  Likewise, the only
expression for integer value one is found in <CODE>const1_rtx</CODE>, the only
expression for integer value two is found in <CODE>const2_rtx</CODE>, and the
only expression for integer value negative one is found in
<CODE>constm1_rtx</CODE>.  Any attempt to create an expression of code
<CODE>const_int</CODE> and value zero, one, two or negative one will return
<CODE>const0_rtx</CODE>, <CODE>const1_rtx</CODE>, <CODE>const2_rtx</CODE> or
<CODE>constm1_rtx</CODE> as appropriate.
<A NAME="IDX862"></A>
Similarly, there is only one object for the integer whose value is
<CODE>STORE_FLAG_VALUE</CODE>.  It is found in <CODE>const_true_rtx</CODE>.  If
<CODE>STORE_FLAG_VALUE</CODE> is one, <CODE>const_true_rtx</CODE> and
<CODE>const1_rtx</CODE> will point to the same object.  If
<CODE>STORE_FLAG_VALUE</CODE> is -1, <CODE>const_true_rtx</CODE> and
<CODE>constm1_rtx</CODE> will point to the same object.
<A NAME="IDX863"></A>
<DT><CODE>(const_double:<VAR>m</VAR> <VAR>addr</VAR> <VAR>i0</VAR> <VAR>i1</VAR> ...)</CODE>
<DD>
Represents either a floating-point constant of mode <VAR>m</VAR> or an
integer constant too large to fit into <CODE>HOST_BITS_PER_WIDE_INT</CODE>
bits but small enough to fit within twice that number of bits (GNU CC
does not provide a mechanism to represent even larger constants).  In
the latter case, <VAR>m</VAR> will be <CODE>VOIDmode</CODE>.

<A NAME="IDX864"></A>
<A NAME="IDX865"></A>
<VAR>addr</VAR> is used to contain the <CODE>mem</CODE> expression that corresponds
to the location in memory that at which the constant can be found.  If
it has not been allocated a memory location, but is on the chain of all
<CODE>const_double</CODE> expressions in this compilation (maintained using an
undisplayed field), <VAR>addr</VAR> contains <CODE>const0_rtx</CODE>.  If it is not
on the chain, <VAR>addr</VAR> contains <CODE>cc0_rtx</CODE>.  <VAR>addr</VAR> is
customarily accessed with the macro <CODE>CONST_DOUBLE_MEM</CODE> and the
chain field via <CODE>CONST_DOUBLE_CHAIN</CODE>.
<A NAME="IDX866"></A>
If <VAR>m</VAR> is <CODE>VOIDmode</CODE>, the bits of the value are stored in
<VAR>i0</VAR> and <VAR>i1</VAR>.  <VAR>i0</VAR> is customarily accessed with the macro
<CODE>CONST_DOUBLE_LOW</CODE> and <VAR>i1</VAR> with <CODE>CONST_DOUBLE_HIGH</CODE>.

If the constant is floating point (regardless of its precision), then
the number of integers used to store the value depends on the size of
<CODE>REAL_VALUE_TYPE</CODE> (see section <A HREF="gcc_17.html#SEC249">Cross Compilation and Floating Point</A>).  The integers
represent a floating point number, but not precisely in the target
machine's or host machine's floating point format.  To convert them to
the precise bit pattern used by the target machine, use the macro
<CODE>REAL_VALUE_TO_TARGET_DOUBLE</CODE> and friends (see section <A HREF="gcc_17.html#SEC234">Output of Data</A>).

<A NAME="IDX867"></A>
<A NAME="IDX868"></A>
<A NAME="IDX869"></A>
The macro <CODE>CONST0_RTX (<VAR>mode</VAR>)</CODE> refers to an expression with
value 0 in mode <VAR>mode</VAR>.  If mode <VAR>mode</VAR> is of mode class
<CODE>MODE_INT</CODE>, it returns <CODE>const0_rtx</CODE>.  Otherwise, it returns a
<CODE>CONST_DOUBLE</CODE> expression in mode <VAR>mode</VAR>.  Similarly, the macro
<CODE>CONST1_RTX (<VAR>mode</VAR>)</CODE> refers to an expression with value 1 in
mode <VAR>mode</VAR> and similarly for <CODE>CONST2_RTX</CODE>.

<A NAME="IDX870"></A>
<DT><CODE>(const_string <VAR>str</VAR>)</CODE>
<DD>
Represents a constant string with value <VAR>str</VAR>.  Currently this is
used only for insn attributes (see section <A HREF="gcc_16.html#SEC190">Instruction Attributes</A>) since constant
strings in C are placed in memory.

<A NAME="IDX871"></A>
<DT><CODE>(symbol_ref:<VAR>mode</VAR> <VAR>symbol</VAR>)</CODE>
<DD>
Represents the value of an assembler label for data.  <VAR>symbol</VAR> is
a string that describes the name of the assembler label.  If it starts
with a <SAMP>`*'</SAMP>, the label is the rest of <VAR>symbol</VAR> not including
the <SAMP>`*'</SAMP>.  Otherwise, the label is <VAR>symbol</VAR>, usually prefixed
with <SAMP>`_'</SAMP>.

The <CODE>symbol_ref</CODE> contains a mode, which is usually <CODE>Pmode</CODE>.
Usually that is the only mode for which a symbol is directly valid.

<A NAME="IDX872"></A>
<DT><CODE>(label_ref <VAR>label</VAR>)</CODE>
<DD>
Represents the value of an assembler label for code.  It contains one
operand, an expression, which must be a <CODE>code_label</CODE> that appears
in the instruction sequence to identify the place where the label
should go.

The reason for using a distinct expression type for code label
references is so that jump optimization can distinguish them.

<DT><CODE>(const:<VAR>m</VAR> <VAR>exp</VAR>)</CODE>
<DD>
Represents a constant that is the result of an assembly-time
arithmetic computation.  The operand, <VAR>exp</VAR>, is an expression that
contains only constants (<CODE>const_int</CODE>, <CODE>symbol_ref</CODE> and
<CODE>label_ref</CODE> expressions) combined with <CODE>plus</CODE> and
<CODE>minus</CODE>.  However, not all combinations are valid, since the
assembler cannot do arbitrary arithmetic on relocatable symbols.

<VAR>m</VAR> should be <CODE>Pmode</CODE>.

<A NAME="IDX873"></A>
<DT><CODE>(high:<VAR>m</VAR> <VAR>exp</VAR>)</CODE>
<DD>
Represents the high-order bits of <VAR>exp</VAR>, usually a
<CODE>symbol_ref</CODE>.  The number of bits is machine-dependent and is
normally the number of bits specified in an instruction that initializes
the high order bits of a register.  It is used with <CODE>lo_sum</CODE> to
represent the typical two-instruction sequence used in RISC machines to
reference a global memory location.

<VAR>m</VAR> should be <CODE>Pmode</CODE>.
</DL>



<H2><A NAME="SEC156" HREF="gcc_toc.html#TOC156">Registers and Memory</A></H2>
<P>
<A NAME="IDX874"></A>
<A NAME="IDX875"></A>

</P>
<P>
Here are the RTL expression types for describing access to machine
registers and to main memory.

</P>
<DL COMPACT>

<DT><CODE>(reg:<VAR>m</VAR> <VAR>n</VAR>)</CODE>
<DD>
<A NAME="IDX876"></A>
 <A NAME="IDX877"></A>
 <A NAME="IDX878"></A>
 
For small values of the integer <VAR>n</VAR> (those that are less than
<CODE>FIRST_PSEUDO_REGISTER</CODE>), this stands for a reference to machine
register number <VAR>n</VAR>: a <STRONG>hard register</STRONG>.  For larger values of
<VAR>n</VAR>, it stands for a temporary value or <STRONG>pseudo register</STRONG>.
The compiler's strategy is to generate code assuming an unlimited
number of such pseudo registers, and later convert them into hard
registers or into memory references.

<VAR>m</VAR> is the machine mode of the reference.  It is necessary because
machines can generally refer to each register in more than one mode.
For example, a register may contain a full word but there may be
instructions to refer to it as a half word or as a single byte, as
well as instructions to refer to it as a floating point number of
various precisions.

Even for a register that the machine can access in only one mode,
the mode must always be specified.

The symbol <CODE>FIRST_PSEUDO_REGISTER</CODE> is defined by the machine
description, since the number of hard registers on the machine is an
invariant characteristic of the machine.  Note, however, that not
all of the machine registers must be general registers.  All the
machine registers that can be used for storage of data are given
hard register numbers, even those that can be used only in certain
instructions or can hold only certain types of data.

A hard register may be accessed in various modes throughout one
function, but each pseudo register is given a natural mode
and is accessed only in that mode.  When it is necessary to describe
an access to a pseudo register using a nonnatural mode, a <CODE>subreg</CODE>
expression is used.

A <CODE>reg</CODE> expression with a machine mode that specifies more than
one word of data may actually stand for several consecutive registers.
If in addition the register number specifies a hardware register, then
it actually represents several consecutive hardware registers starting
with the specified one.

Each pseudo register number used in a function's RTL code is
represented by a unique <CODE>reg</CODE> expression.

<A NAME="IDX879"></A>
<A NAME="IDX880"></A>
Some pseudo register numbers, those within the range of
<CODE>FIRST_VIRTUAL_REGISTER</CODE> to <CODE>LAST_VIRTUAL_REGISTER</CODE> only
appear during the RTL generation phase and are eliminated before the
optimization phases.  These represent locations in the stack frame that
cannot be determined until RTL generation for the function has been
completed.  The following virtual register numbers are defined:

<DL COMPACT>

<DT><CODE>VIRTUAL_INCOMING_ARGS_REGNUM</CODE>
<DD>
<A NAME="IDX881"></A>
 
This points to the first word of the incoming arguments passed on the
stack.  Normally these arguments are placed there by the caller, but the
callee may have pushed some arguments that were previously passed in
registers.

<A NAME="IDX882"></A>
<A NAME="IDX883"></A>
When RTL generation is complete, this virtual register is replaced
by the sum of the register given by <CODE>ARG_POINTER_REGNUM</CODE> and the
value of <CODE>FIRST_PARM_OFFSET</CODE>.

<A NAME="IDX884"></A>
<A NAME="IDX885"></A>
<DT><CODE>VIRTUAL_STACK_VARS_REGNUM</CODE>
<DD>
If <CODE>FRAME_GROWS_DOWNWARD</CODE> is defined, this points to immediately
above the first variable on the stack.  Otherwise, it points to the
first variable on the stack.

<A NAME="IDX886"></A>
<A NAME="IDX887"></A>
<CODE>VIRTUAL_STACK_VARS_REGNUM</CODE> is replaced with the sum of the
register given by <CODE>FRAME_POINTER_REGNUM</CODE> and the value
<CODE>STARTING_FRAME_OFFSET</CODE>.

<A NAME="IDX888"></A>
<DT><CODE>VIRTUAL_STACK_DYNAMIC_REGNUM</CODE>
<DD>
This points to the location of dynamically allocated memory on the stack
immediately after the stack pointer has been adjusted by the amount of
memory desired.

<A NAME="IDX889"></A>
<A NAME="IDX890"></A>
This virtual register is replaced by the sum of the register given by
<CODE>STACK_POINTER_REGNUM</CODE> and the value <CODE>STACK_DYNAMIC_OFFSET</CODE>.

<A NAME="IDX891"></A>
<DT><CODE>VIRTUAL_OUTGOING_ARGS_REGNUM</CODE>
<DD>
This points to the location in the stack at which outgoing arguments
should be written when the stack is pre-pushed (arguments pushed using
push insns should always use <CODE>STACK_POINTER_REGNUM</CODE>).

<A NAME="IDX892"></A>
This virtual register is replaced by the sum of the register given by
<CODE>STACK_POINTER_REGNUM</CODE> and the value <CODE>STACK_POINTER_OFFSET</CODE>.
</DL>

<A NAME="IDX893"></A>
<DT><CODE>(subreg:<VAR>m</VAR> <VAR>reg</VAR> <VAR>wordnum</VAR>)</CODE>
<DD>
<CODE>subreg</CODE> expressions are used to refer to a register in a machine
mode other than its natural one, or to refer to one register of
a multi-word <CODE>reg</CODE> that actually refers to several registers.

Each pseudo-register has a natural mode.  If it is necessary to
operate on it in a different mode--for example, to perform a fullword
move instruction on a pseudo-register that contains a single
byte--the pseudo-register must be enclosed in a <CODE>subreg</CODE>.  In
such a case, <VAR>wordnum</VAR> is zero.

Usually <VAR>m</VAR> is at least as narrow as the mode of <VAR>reg</VAR>, in which
case it is restricting consideration to only the bits of <VAR>reg</VAR> that
are in <VAR>m</VAR>.

Sometimes <VAR>m</VAR> is wider than the mode of <VAR>reg</VAR>.  These
<CODE>subreg</CODE> expressions are often called <STRONG>paradoxical</STRONG>.  They are
used in cases where we want to refer to an object in a wider mode but do
not care what value the additional bits have.  The reload pass ensures
that paradoxical references are only made to hard registers.

The other use of <CODE>subreg</CODE> is to extract the individual registers of
a multi-register value.  Machine modes such as <CODE>DImode</CODE> and
<CODE>TImode</CODE> can indicate values longer than a word, values which
usually require two or more consecutive registers.  To access one of the
registers, use a <CODE>subreg</CODE> with mode <CODE>SImode</CODE> and a
<VAR>wordnum</VAR> that says which register.

Storing in a non-paradoxical <CODE>subreg</CODE> has undefined results for
bits belonging to the same word as the <CODE>subreg</CODE>.  This laxity makes
it easier to generate efficient code for such instructions.  To
represent an instruction that preserves all the bits outside of those in
the <CODE>subreg</CODE>, use <CODE>strict_low_part</CODE> around the <CODE>subreg</CODE>.

<A NAME="IDX894"></A>
The compilation parameter <CODE>WORDS_BIG_ENDIAN</CODE>, if set to 1, says
that word number zero is the most significant part; otherwise, it is
the least significant part.

<A NAME="IDX895"></A>
On a few targets, <CODE>FLOAT_WORDS_BIG_ENDIAN</CODE> disagrees with
<CODE>WORDS_BIG_ENDIAN</CODE>.
However, most parts of the compiler treat floating point values as if
they had the same endianness as integer values.  This works because
they handle them solely as a collection of integer values, with no
particular numerical value.  Only real.c and the runtime libraries
care about <CODE>FLOAT_WORDS_BIG_ENDIAN</CODE>.

<A NAME="IDX896"></A>
<A NAME="IDX897"></A>
<A NAME="IDX898"></A>
Between the combiner pass and the reload pass, it is possible to have a
paradoxical <CODE>subreg</CODE> which contains a <CODE>mem</CODE> instead of a
<CODE>reg</CODE> as its first operand.  After the reload pass, it is also
possible to have a non-paradoxical <CODE>subreg</CODE> which contains a
<CODE>mem</CODE>; this usually occurs when the <CODE>mem</CODE> is a stack slot
which replaced a pseudo register.

Note that it is not valid to access a <CODE>DFmode</CODE> value in <CODE>SFmode</CODE>
using a <CODE>subreg</CODE>.  On some machines the most significant part of a
<CODE>DFmode</CODE> value does not have the same format as a single-precision
floating value.

It is also not valid to access a single word of a multi-word value in a
hard register when less registers can hold the value than would be
expected from its size.  For example, some 32-bit machines have
floating-point registers that can hold an entire <CODE>DFmode</CODE> value.
If register 10 were such a register <CODE>(subreg:SI (reg:DF 10) 1)</CODE>
would be invalid because there is no way to convert that reference to
a single machine register.  The reload pass prevents <CODE>subreg</CODE>
expressions such as these from being formed.

<A NAME="IDX899"></A>
<A NAME="IDX900"></A>
The first operand of a <CODE>subreg</CODE> expression is customarily accessed 
with the <CODE>SUBREG_REG</CODE> macro and the second operand is customarily
accessed with the <CODE>SUBREG_WORD</CODE> macro.

<A NAME="IDX901"></A>
<A NAME="IDX902"></A>
<DT><CODE>(scratch:<VAR>m</VAR>)</CODE>
<DD>
This represents a scratch register that will be required for the
execution of a single instruction and not used subsequently.  It is
converted into a <CODE>reg</CODE> by either the local register allocator or
the reload pass.

<CODE>scratch</CODE> is usually present inside a <CODE>clobber</CODE> operation
(see section <A HREF="gcc_15.html#SEC162">Side Effect Expressions</A>).

<A NAME="IDX903"></A>
<A NAME="IDX904"></A>
<DT><CODE>(cc0)</CODE>
<DD>
This refers to the machine's condition code register.  It has no
operands and may not have a machine mode.  There are two ways to use it:


<UL>
<LI>

To stand for a complete set of condition code flags.  This is best on
most machines, where each comparison sets the entire series of flags.

With this technique, <CODE>(cc0)</CODE> may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) and in comparison operators comparing against zero
(<CODE>const_int</CODE> with value zero; that is to say, <CODE>const0_rtx</CODE>).

<LI>

To stand for a single flag that is the result of a single condition.
This is useful on machines that have only a single flag bit, and in
which comparison instructions must specify the condition to test.

With this technique, <CODE>(cc0)</CODE> may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) where the source is a comparison operator, and as the
first operand of <CODE>if_then_else</CODE> (in a conditional branch).
</UL>

<A NAME="IDX905"></A>
There is only one expression object of code <CODE>cc0</CODE>; it is the
value of the variable <CODE>cc0_rtx</CODE>.  Any attempt to create an
expression of code <CODE>cc0</CODE> will return <CODE>cc0_rtx</CODE>.

Instructions can set the condition code implicitly.  On many machines,
nearly all instructions set the condition code based on the value that
they compute or store.  It is not necessary to record these actions
explicitly in the RTL because the machine description includes a
prescription for recognizing the instructions that do so (by means of
the macro <CODE>NOTICE_UPDATE_CC</CODE>).  See section <A HREF="gcc_17.html#SEC228">Condition Code Status</A>.  Only
instructions whose sole purpose is to set the condition code, and
instructions that use the condition code, need mention <CODE>(cc0)</CODE>.

On some machines, the condition code register is given a register number
and a <CODE>reg</CODE> is used instead of <CODE>(cc0)</CODE>.  This is usually the
preferable approach if only a small subset of instructions modify the
condition code.  Other machines store condition codes in general
registers; in such cases a pseudo register should be used.

Some machines, such as the Sparc and RS/6000, have two sets of
arithmetic instructions, one that sets and one that does not set the
condition code.  This is best handled by normally generating the
instruction that does not set the condition code, and making a pattern
that both performs the arithmetic and sets the condition code register
(which would not be <CODE>(cc0)</CODE> in this case).  For examples, search
for <SAMP>`addcc'</SAMP> and <SAMP>`andcc'</SAMP> in <TT>`sparc.md'</TT>.

<A NAME="IDX906"></A>
<DT><CODE>(pc)</CODE>
<DD>
<A NAME="IDX907"></A>
This represents the machine's program counter.  It has no operands and
may not have a machine mode.  <CODE>(pc)</CODE> may be validly used only in
certain specific contexts in jump instructions.

<A NAME="IDX908"></A>
There is only one expression object of code <CODE>pc</CODE>; it is the value
of the variable <CODE>pc_rtx</CODE>.  Any attempt to create an expression of
code <CODE>pc</CODE> will return <CODE>pc_rtx</CODE>.

All instructions that do not jump alter the program counter implicitly
by incrementing it, but there is no need to mention this in the RTL.

<A NAME="IDX909"></A>
<DT><CODE>(mem:<VAR>m</VAR> <VAR>addr</VAR>)</CODE>
<DD>
This RTX represents a reference to main memory at an address
represented by the expression <VAR>addr</VAR>.  <VAR>m</VAR> specifies how large
a unit of memory is accessed.

<A NAME="IDX910"></A>
<DT><CODE>(addressof:<VAR>m</VAR> <VAR>reg</VAR>)</CODE>
<DD>
This RTX represents a request for the address of register <VAR>reg</VAR>.  Its mode
is always <CODE>Pmode</CODE>.  If there are any <CODE>addressof</CODE>
expressions left in the function after CSE, <VAR>reg</VAR> is forced into the
stack and the <CODE>addressof</CODE> expression is replaced with a <CODE>plus</CODE>
expression for the address of its stack slot.
</DL>



<H2><A NAME="SEC157" HREF="gcc_toc.html#TOC157">RTL Expressions for Arithmetic</A></H2>
<P>
<A NAME="IDX911"></A>
<A NAME="IDX912"></A>
<A NAME="IDX913"></A>

</P>
<P>
Unless otherwise specified, all the operands of arithmetic expressions
must be valid for mode <VAR>m</VAR>.  An operand is valid for mode <VAR>m</VAR>
if it has mode <VAR>m</VAR>, or if it is a <CODE>const_int</CODE> or
<CODE>const_double</CODE> and <VAR>m</VAR> is a mode of class <CODE>MODE_INT</CODE>.

</P>
<P>
For commutative binary operations, constants should be placed in the
second operand.

</P>
<DL COMPACT>

<DT><CODE>(plus:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<A NAME="IDX914"></A>
 <A NAME="IDX915"></A>
 <A NAME="IDX916"></A>
 
Represents the sum of the values represented by <VAR>x</VAR> and <VAR>y</VAR>
carried out in machine mode <VAR>m</VAR>. 

<A NAME="IDX917"></A>
<DT><CODE>(lo_sum:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>plus</CODE>, except that it represents that sum of <VAR>x</VAR> and the
low-order bits of <VAR>y</VAR>.  The number of low order bits is
machine-dependent but is normally the number of bits in a <CODE>Pmode</CODE>
item minus the number of bits set by the <CODE>high</CODE> code
(see section <A HREF="gcc_15.html#SEC155">Constant Expression Types</A>).

<VAR>m</VAR> should be <CODE>Pmode</CODE>.

<A NAME="IDX918"></A>
<A NAME="IDX919"></A>
<A NAME="IDX920"></A>
<DT><CODE>(minus:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>plus</CODE> but represents subtraction.

<A NAME="IDX921"></A>
<A NAME="IDX922"></A>
<DT><CODE>(compare:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the result of subtracting <VAR>y</VAR> from <VAR>x</VAR> for purposes
of comparison.  The result is computed without overflow, as if with
infinite precision.

Of course, machines can't really subtract with infinite precision.
However, they can pretend to do so when only the sign of the
result will be used, which is the case when the result is stored
in the condition code.   And that is the only way this kind of expression
may validly be used: as a value to be stored in the condition codes.

The mode <VAR>m</VAR> is not related to the modes of <VAR>x</VAR> and <VAR>y</VAR>,
but instead is the mode of the condition code value.  If <CODE>(cc0)</CODE>
is used, it is <CODE>VOIDmode</CODE>.  Otherwise it is some mode in class
<CODE>MODE_CC</CODE>, often <CODE>CCmode</CODE>.  See section <A HREF="gcc_17.html#SEC228">Condition Code Status</A>.

Normally, <VAR>x</VAR> and <VAR>y</VAR> must have the same mode.  Otherwise,
<CODE>compare</CODE> is valid only if the mode of <VAR>x</VAR> is in class
<CODE>MODE_INT</CODE> and <VAR>y</VAR> is a <CODE>const_int</CODE> or
<CODE>const_double</CODE> with mode <CODE>VOIDmode</CODE>.  The mode of <VAR>x</VAR>
determines what mode the comparison is to be done in; thus it must not
be <CODE>VOIDmode</CODE>.

If one of the operands is a constant, it should be placed in the
second operand and the comparison code adjusted as appropriate.  

A <CODE>compare</CODE> specifying two <CODE>VOIDmode</CODE> constants is not valid
since there is no way to know in what mode the comparison is to be
performed; the comparison must either be folded during the compilation
or the first operand must be loaded into a register while its mode is
still known.

<A NAME="IDX923"></A>
<DT><CODE>(neg:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the negation (subtraction from zero) of the value represented
by <VAR>x</VAR>, carried out in mode <VAR>m</VAR>.

<A NAME="IDX924"></A>
<A NAME="IDX925"></A>
<A NAME="IDX926"></A>
<DT><CODE>(mult:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the signed product of the values represented by <VAR>x</VAR> and
<VAR>y</VAR> carried out in machine mode <VAR>m</VAR>.

Some machines support a multiplication that generates a product wider
than the operands.  Write the pattern for this as


<PRE>
(mult:<VAR>m</VAR> (sign_extend:<VAR>m</VAR> <VAR>x</VAR>) (sign_extend:<VAR>m</VAR> <VAR>y</VAR>))
</PRE>

where <VAR>m</VAR> is wider than the modes of <VAR>x</VAR> and <VAR>y</VAR>, which need
not be the same.

Write patterns for unsigned widening multiplication similarly using
<CODE>zero_extend</CODE>.

<A NAME="IDX927"></A>
<A NAME="IDX928"></A>
<A NAME="IDX929"></A>
<A NAME="IDX930"></A>
<DT><CODE>(div:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the quotient in signed division of <VAR>x</VAR> by <VAR>y</VAR>,
carried out in machine mode <VAR>m</VAR>.  If <VAR>m</VAR> is a floating point
mode, it represents the exact quotient; otherwise, the integerized
quotient.

Some machines have division instructions in which the operands and
quotient widths are not all the same; you should represent 
such instructions using <CODE>truncate</CODE> and <CODE>sign_extend</CODE> as in,


<PRE>
(truncate:<VAR>m1</VAR> (div:<VAR>m2</VAR> <VAR>x</VAR> (sign_extend:<VAR>m2</VAR> <VAR>y</VAR>)))
</PRE>

<A NAME="IDX931"></A>
<A NAME="IDX932"></A>
<A NAME="IDX933"></A>
<DT><CODE>(udiv:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>div</CODE> but represents unsigned division.

<A NAME="IDX934"></A>
<A NAME="IDX935"></A>
<A NAME="IDX936"></A>
<A NAME="IDX937"></A>
<DT><CODE>(mod:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<DT><CODE>(umod:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>div</CODE> and <CODE>udiv</CODE> but represent the remainder instead of
the quotient.

<A NAME="IDX938"></A>
<A NAME="IDX939"></A>
<A NAME="IDX940"></A>
<A NAME="IDX941"></A>
<DT><CODE>(smin:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<DT><CODE>(smax:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the smaller (for <CODE>smin</CODE>) or larger (for <CODE>smax</CODE>) of
<VAR>x</VAR> and <VAR>y</VAR>, interpreted as signed integers in mode <VAR>m</VAR>.

<A NAME="IDX942"></A>
<A NAME="IDX943"></A>
<A NAME="IDX944"></A>
<DT><CODE>(umin:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<DT><CODE>(umax:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>smin</CODE> and <CODE>smax</CODE>, but the values are interpreted as unsigned
integers.

<A NAME="IDX945"></A>
<A NAME="IDX946"></A>
<A NAME="IDX947"></A>
<DT><CODE>(not:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the bitwise complement of the value represented by <VAR>x</VAR>,
carried out in mode <VAR>m</VAR>, which must be a fixed-point machine mode.

<A NAME="IDX948"></A>
<A NAME="IDX949"></A>
<A NAME="IDX950"></A>
<DT><CODE>(and:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the bitwise logical-and of the values represented by
<VAR>x</VAR> and <VAR>y</VAR>, carried out in machine mode <VAR>m</VAR>, which must be
a fixed-point machine mode.

<A NAME="IDX951"></A>
<A NAME="IDX952"></A>
<A NAME="IDX953"></A>
<DT><CODE>(ior:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the bitwise inclusive-or of the values represented by <VAR>x</VAR>
and <VAR>y</VAR>, carried out in machine mode <VAR>m</VAR>, which must be a
fixed-point mode.

<A NAME="IDX954"></A>
<A NAME="IDX955"></A>
<A NAME="IDX956"></A>
<DT><CODE>(xor:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the bitwise exclusive-or of the values represented by <VAR>x</VAR>
and <VAR>y</VAR>, carried out in machine mode <VAR>m</VAR>, which must be a
fixed-point mode.

<A NAME="IDX957"></A>
<A NAME="IDX958"></A>
<A NAME="IDX959"></A>
<A NAME="IDX960"></A>
<DT><CODE>(ashift:<VAR>m</VAR> <VAR>x</VAR> <VAR>c</VAR>)</CODE>
<DD>
Represents the result of arithmetically shifting <VAR>x</VAR> left by <VAR>c</VAR>
places.  <VAR>x</VAR> have mode <VAR>m</VAR>, a fixed-point machine mode.  <VAR>c</VAR>
be a fixed-point mode or be a constant with mode <CODE>VOIDmode</CODE>; which
mode is determined by the mode called for in the machine description
entry for the left-shift instruction.  For example, on the Vax, the mode
of <VAR>c</VAR> is <CODE>QImode</CODE> regardless of <VAR>m</VAR>.

<A NAME="IDX961"></A>
<A NAME="IDX962"></A>
<A NAME="IDX963"></A>
<DT><CODE>(lshiftrt:<VAR>m</VAR> <VAR>x</VAR> <VAR>c</VAR>)</CODE>
<DD>
<DT><CODE>(ashiftrt:<VAR>m</VAR> <VAR>x</VAR> <VAR>c</VAR>)</CODE>
<DD>
Like <CODE>ashift</CODE> but for right shift.  Unlike the case for left shift,
these two operations are distinct.

<A NAME="IDX964"></A>
<A NAME="IDX965"></A>
<A NAME="IDX966"></A>
<A NAME="IDX967"></A>
<A NAME="IDX968"></A>
<DT><CODE>(rotate:<VAR>m</VAR> <VAR>x</VAR> <VAR>c</VAR>)</CODE>
<DD>
<DT><CODE>(rotatert:<VAR>m</VAR> <VAR>x</VAR> <VAR>c</VAR>)</CODE>
<DD>
Similar but represent left and right rotate.  If <VAR>c</VAR> is a constant,
use <CODE>rotate</CODE>.

<A NAME="IDX969"></A>
<A NAME="IDX970"></A>
<DT><CODE>(abs:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the absolute value of <VAR>x</VAR>, computed in mode <VAR>m</VAR>.

<A NAME="IDX971"></A>
<A NAME="IDX972"></A>
<DT><CODE>(sqrt:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the square root of <VAR>x</VAR>, computed in mode <VAR>m</VAR>.
Most often <VAR>m</VAR> will be a floating point mode.

<A NAME="IDX973"></A>
<DT><CODE>(ffs:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents one plus the index of the least significant 1-bit in
<VAR>x</VAR>, represented as an integer of mode <VAR>m</VAR>.  (The value is
zero if <VAR>x</VAR> is zero.)  The mode of <VAR>x</VAR> need not be <VAR>m</VAR>;
depending on the target machine, various mode combinations may be
valid.
</DL>



<H2><A NAME="SEC158" HREF="gcc_toc.html#TOC158">Comparison Operations</A></H2>
<P>
<A NAME="IDX974"></A>

</P>
<P>
Comparison operators test a relation on two operands and are considered
to represent a machine-dependent nonzero value described by, but not
necessarily equal to, <CODE>STORE_FLAG_VALUE</CODE> (see section <A HREF="gcc_17.html#SEC250">Miscellaneous Parameters</A>)
if the relation holds, or zero if it does not.  The mode of the
comparison operation is independent of the mode of the data being
compared.  If the comparison operation is being tested (e.g., the first
operand of an <CODE>if_then_else</CODE>), the mode must be <CODE>VOIDmode</CODE>.
If the comparison operation is producing data to be stored in some
variable, the mode must be in class <CODE>MODE_INT</CODE>.  All comparison
operations producing data must use the same mode, which is
machine-specific.

</P>
<P>
<A NAME="IDX975"></A>
There are two ways that comparison operations may be used.  The
comparison operators may be used to compare the condition codes
<CODE>(cc0)</CODE> against zero, as in <CODE>(eq (cc0) (const_int 0))</CODE>.  Such
a construct actually refers to the result of the preceding instruction
in which the condition codes were set.  The instructing setting the
condition code must be adjacent to the instruction using the condition
code; only <CODE>note</CODE> insns may separate them.

</P>
<P>
Alternatively, a comparison operation may directly compare two data
objects.  The mode of the comparison is determined by the operands; they
must both be valid for a common machine mode.  A comparison with both
operands constant would be invalid as the machine mode could not be
deduced from it, but such a comparison should never exist in RTL due to
constant folding.

</P>
<P>
In the example above, if <CODE>(cc0)</CODE> were last set to
<CODE>(compare <VAR>x</VAR> <VAR>y</VAR>)</CODE>, the comparison operation is
identical to <CODE>(eq <VAR>x</VAR> <VAR>y</VAR>)</CODE>.  Usually only one style
of comparisons is supported on a particular machine, but the combine
pass will try to merge the operations to produce the <CODE>eq</CODE> shown
in case it exists in the context of the particular insn involved.

</P>
<P>
Inequality comparisons come in two flavors, signed and unsigned.  Thus,
there are distinct expression codes <CODE>gt</CODE> and <CODE>gtu</CODE> for signed and
unsigned greater-than.  These can produce different results for the same
pair of integer values: for example, 1 is signed greater-than -1 but not
unsigned greater-than, because -1 when regarded as unsigned is actually
<CODE>0xffffffff</CODE> which is greater than 1.

</P>
<P>
The signed comparisons are also used for floating point values.  Floating
point comparisons are distinguished by the machine modes of the operands.

</P>
<DL COMPACT>

<DT><CODE>(eq:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<A NAME="IDX976"></A>
 <A NAME="IDX977"></A>
 
1 if the values represented by <VAR>x</VAR> and <VAR>y</VAR> are equal,
otherwise 0.

<A NAME="IDX978"></A>
<A NAME="IDX979"></A>
<DT><CODE>(ne:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
1 if the values represented by <VAR>x</VAR> and <VAR>y</VAR> are not equal,
otherwise 0.

<A NAME="IDX980"></A>
<A NAME="IDX981"></A>
<DT><CODE>(gt:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
1 if the <VAR>x</VAR> is greater than <VAR>y</VAR>.  If they are fixed-point,
the comparison is done in a signed sense.

<A NAME="IDX982"></A>
<A NAME="IDX983"></A>
<A NAME="IDX984"></A>
<DT><CODE>(gtu:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>gt</CODE> but does unsigned comparison, on fixed-point numbers only.

<A NAME="IDX985"></A>
<A NAME="IDX986"></A>
<A NAME="IDX987"></A>
<A NAME="IDX988"></A>
<DT><CODE>(lt:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<DT><CODE>(ltu:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>gt</CODE> and <CODE>gtu</CODE> but test for "less than".

<A NAME="IDX989"></A>
<A NAME="IDX990"></A>
<A NAME="IDX991"></A>
<A NAME="IDX992"></A>
<DT><CODE>(ge:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<DT><CODE>(geu:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>gt</CODE> and <CODE>gtu</CODE> but test for "greater than or equal".

<A NAME="IDX993"></A>
<A NAME="IDX994"></A>
<A NAME="IDX995"></A>
<A NAME="IDX996"></A>
<DT><CODE>(le:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
<DT><CODE>(leu:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Like <CODE>gt</CODE> and <CODE>gtu</CODE> but test for "less than or equal".

<A NAME="IDX997"></A>
<DT><CODE>(if_then_else <VAR>cond</VAR> <VAR>then</VAR> <VAR>else</VAR>)</CODE>
<DD>
This is not a comparison operation but is listed here because it is
always used in conjunction with a comparison operation.  To be
precise, <VAR>cond</VAR> is a comparison expression.  This expression
represents a choice, according to <VAR>cond</VAR>, between the value
represented by <VAR>then</VAR> and the one represented by <VAR>else</VAR>.

On most machines, <CODE>if_then_else</CODE> expressions are valid only
to express conditional jumps.

<A NAME="IDX998"></A>
<DT><CODE>(cond [<VAR>test1</VAR> <VAR>value1</VAR> <VAR>test2</VAR> <VAR>value2</VAR> ...] <VAR>default</VAR>)</CODE>
<DD>
Similar to <CODE>if_then_else</CODE>, but more general.  Each of <VAR>test1</VAR>,
<VAR>test2</VAR>, ... is performed in turn.  The result of this expression is
the <VAR>value</VAR> corresponding to the first non-zero test, or <VAR>default</VAR> if
none of the tests are non-zero expressions.

This is currently not valid for instruction patterns and is supported only
for insn attributes.  See section <A HREF="gcc_16.html#SEC190">Instruction Attributes</A>.
</DL>



<H2><A NAME="SEC159" HREF="gcc_toc.html#TOC159">Bit Fields</A></H2>
<P>
<A NAME="IDX999"></A>

</P>
<P>
Special expression codes exist to represent bitfield instructions.
These types of expressions are lvalues in RTL; they may appear
on the left side of an assignment, indicating insertion of a value
into the specified bit field.

</P>
<DL COMPACT>

<DT><CODE>(sign_extract:<VAR>m</VAR> <VAR>loc</VAR> <VAR>size</VAR> <VAR>pos</VAR>)</CODE>
<DD>
<A NAME="IDX1000"></A>
 <A NAME="IDX1001"></A>
 
This represents a reference to a sign-extended bit field contained or
starting in <VAR>loc</VAR> (a memory or register reference).  The bit field
is <VAR>size</VAR> bits wide and starts at bit <VAR>pos</VAR>.  The compilation
option <CODE>BITS_BIG_ENDIAN</CODE> says which end of the memory unit
<VAR>pos</VAR> counts from.

If <VAR>loc</VAR> is in memory, its mode must be a single-byte integer mode.
If <VAR>loc</VAR> is in a register, the mode to use is specified by the
operand of the <CODE>insv</CODE> or <CODE>extv</CODE> pattern
(see section <A HREF="gcc_16.html#SEC182">Standard Pattern Names For Generation</A>) and is usually a full-word integer mode,
which is the default if none is specified.

The mode of <VAR>pos</VAR> is machine-specific and is also specified
in the <CODE>insv</CODE> or <CODE>extv</CODE> pattern.

The mode <VAR>m</VAR> is the same as the mode that would be used for
<VAR>loc</VAR> if it were a register.

<A NAME="IDX1002"></A>
<DT><CODE>(zero_extract:<VAR>m</VAR> <VAR>loc</VAR> <VAR>size</VAR> <VAR>pos</VAR>)</CODE>
<DD>
Like <CODE>sign_extract</CODE> but refers to an unsigned or zero-extended
bit field.  The same sequence of bits are extracted, but they
are filled to an entire word with zeros instead of by sign-extension.
</DL>



<H2><A NAME="SEC160" HREF="gcc_toc.html#TOC160">Conversions</A></H2>
<P>
<A NAME="IDX1003"></A>
<A NAME="IDX1004"></A>

</P>
<P>
All conversions between machine modes must be represented by
explicit conversion operations.  For example, an expression
which is the sum of a byte and a full word cannot be written as
<CODE>(plus:SI (reg:QI 34) (reg:SI 80))</CODE> because the <CODE>plus</CODE>
operation requires two operands of the same machine mode.
Therefore, the byte-sized operand is enclosed in a conversion
operation, as in

</P>

<PRE>
(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))
</PRE>

<P>
The conversion operation is not a mere placeholder, because there
may be more than one way of converting from a given starting mode
to the desired final mode.  The conversion operation code says how
to do it.

</P>
<P>
For all conversion operations, <VAR>x</VAR> must not be <CODE>VOIDmode</CODE>
because the mode in which to do the conversion would not be known.
The conversion must either be done at compile-time or <VAR>x</VAR>
must be placed into a register.

</P>
<DL COMPACT>

<DT><CODE>(sign_extend:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
<A NAME="IDX1005"></A>
 
Represents the result of sign-extending the value <VAR>x</VAR>
to machine mode <VAR>m</VAR>.  <VAR>m</VAR> must be a fixed-point mode
and <VAR>x</VAR> a fixed-point value of a mode narrower than <VAR>m</VAR>.

<A NAME="IDX1006"></A>
<DT><CODE>(zero_extend:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the result of zero-extending the value <VAR>x</VAR>
to machine mode <VAR>m</VAR>.  <VAR>m</VAR> must be a fixed-point mode
and <VAR>x</VAR> a fixed-point value of a mode narrower than <VAR>m</VAR>.

<A NAME="IDX1007"></A>
<DT><CODE>(float_extend:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the result of extending the value <VAR>x</VAR>
to machine mode <VAR>m</VAR>.  <VAR>m</VAR> must be a floating point mode
and <VAR>x</VAR> a floating point value of a mode narrower than <VAR>m</VAR>.

<A NAME="IDX1008"></A>
<DT><CODE>(truncate:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the result of truncating the value <VAR>x</VAR>
to machine mode <VAR>m</VAR>.  <VAR>m</VAR> must be a fixed-point mode
and <VAR>x</VAR> a fixed-point value of a mode wider than <VAR>m</VAR>.

<A NAME="IDX1009"></A>
<DT><CODE>(float_truncate:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the result of truncating the value <VAR>x</VAR>
to machine mode <VAR>m</VAR>.  <VAR>m</VAR> must be a floating point mode
and <VAR>x</VAR> a floating point value of a mode wider than <VAR>m</VAR>.

<A NAME="IDX1010"></A>
<DT><CODE>(float:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the result of converting fixed point value <VAR>x</VAR>,
regarded as signed, to floating point mode <VAR>m</VAR>.

<A NAME="IDX1011"></A>
<DT><CODE>(unsigned_float:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the result of converting fixed point value <VAR>x</VAR>,
regarded as unsigned, to floating point mode <VAR>m</VAR>.

<A NAME="IDX1012"></A>
<DT><CODE>(fix:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
When <VAR>m</VAR> is a fixed point mode, represents the result of
converting floating point value <VAR>x</VAR> to mode <VAR>m</VAR>, regarded as
signed.  How rounding is done is not specified, so this operation may
be used validly in compiling C code only for integer-valued operands.

<A NAME="IDX1013"></A>
<DT><CODE>(unsigned_fix:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the result of converting floating point value <VAR>x</VAR> to
fixed point mode <VAR>m</VAR>, regarded as unsigned.  How rounding is done
is not specified.

<A NAME="IDX1014"></A>
<DT><CODE>(fix:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
When <VAR>m</VAR> is a floating point mode, represents the result of
converting floating point value <VAR>x</VAR> (valid for mode <VAR>m</VAR>) to an
integer, still represented in floating point mode <VAR>m</VAR>, by rounding
towards zero.
</DL>



<H2><A NAME="SEC161" HREF="gcc_toc.html#TOC161">Declarations</A></H2>
<P>
<A NAME="IDX1015"></A>
<A NAME="IDX1016"></A>

</P>
<P>
Declaration expression codes do not represent arithmetic operations
but rather state assertions about their operands.

</P>
<DL COMPACT>

<DT><CODE>(strict_low_part (subreg:<VAR>m</VAR> (reg:<VAR>n</VAR> <VAR>r</VAR>) 0))</CODE>
<DD>
<A NAME="IDX1017"></A>
 <A NAME="IDX1018"></A>
 
This expression code is used in only one context: as the destination operand of a
<CODE>set</CODE> expression.  In addition, the operand of this expression
must be a non-paradoxical <CODE>subreg</CODE> expression.

The presence of <CODE>strict_low_part</CODE> says that the part of the
register which is meaningful in mode <VAR>n</VAR>, but is not part of
mode <VAR>m</VAR>, is not to be altered.  Normally, an assignment to such
a subreg is allowed to have undefined effects on the rest of the
register when <VAR>m</VAR> is less than a word.
</DL>



<H2><A NAME="SEC162" HREF="gcc_toc.html#TOC162">Side Effect Expressions</A></H2>
<P>
<A NAME="IDX1019"></A>

</P>
<P>
The expression codes described so far represent values, not actions.
But machine instructions never produce values; they are meaningful
only for their side effects on the state of the machine.  Special
expression codes are used to represent side effects.

</P>
<P>
The body of an instruction is always one of these side effect codes;
the codes described above, which represent values, appear only as
the operands of these.

</P>
<DL COMPACT>

<DT><CODE>(set <VAR>lval</VAR> <VAR>x</VAR>)</CODE>
<DD>
<A NAME="IDX1020"></A>
 
Represents the action of storing the value of <VAR>x</VAR> into the place
represented by <VAR>lval</VAR>.  <VAR>lval</VAR> must be an expression
representing a place that can be stored in: <CODE>reg</CODE> (or
<CODE>subreg</CODE> or <CODE>strict_low_part</CODE>), <CODE>mem</CODE>, <CODE>pc</CODE> or
<CODE>cc0</CODE>.
If <VAR>lval</VAR> is a <CODE>reg</CODE>, <CODE>subreg</CODE> or <CODE>mem</CODE>, it has a
machine mode; then <VAR>x</VAR> must be valid for that mode.
If <VAR>lval</VAR> is a <CODE>reg</CODE> whose machine mode is less than the full
width of the register, then it means that the part of the register
specified by the machine mode is given the specified value and the
rest of the register receives an undefined value.  Likewise, if
<VAR>lval</VAR> is a <CODE>subreg</CODE> whose machine mode is narrower than
the mode of the register, the rest of the register can be changed in
an undefined way.

If <VAR>lval</VAR> is a <CODE>strict_low_part</CODE> of a <CODE>subreg</CODE>, then the
part of the register specified by the machine mode of the
<CODE>subreg</CODE> is given the value <VAR>x</VAR> and the rest of the register
is not changed.
If <VAR>lval</VAR> is <CODE>(cc0)</CODE>, it has no machine mode, and <VAR>x</VAR> may
be either a <CODE>compare</CODE> expression or a value that may have any mode.
The latter case represents a "test" instruction.  The expression
<CODE>(set (cc0) (reg:<VAR>m</VAR> <VAR>n</VAR>))</CODE> is equivalent to
<CODE>(set (cc0) (compare (reg:<VAR>m</VAR> <VAR>n</VAR>) (const_int 0)))</CODE>.
Use the former expression to save space during the compilation.

<A NAME="IDX1021"></A>
<A NAME="IDX1022"></A>
If <VAR>lval</VAR> is <CODE>(pc)</CODE>, we have a jump instruction, and the
possibilities for <VAR>x</VAR> are very limited.  It may be a
<CODE>label_ref</CODE> expression (unconditional jump).  It may be an
<CODE>if_then_else</CODE> (conditional jump), in which case either the
second or the third operand must be <CODE>(pc)</CODE> (for the case which
does not jump) and the other of the two must be a <CODE>label_ref</CODE>
(for the case which does jump).  <VAR>x</VAR> may also be a <CODE>mem</CODE> or
<CODE>(plus:SI (pc) <VAR>y</VAR>)</CODE>, where <VAR>y</VAR> may be a <CODE>reg</CODE> or a
<CODE>mem</CODE>; these unusual patterns are used to represent jumps through
branch tables.
If <VAR>lval</VAR> is neither <CODE>(cc0)</CODE> nor <CODE>(pc)</CODE>, the mode of
<VAR>lval</VAR> must not be <CODE>VOIDmode</CODE> and the mode of <VAR>x</VAR> must be
valid for the mode of <VAR>lval</VAR>.

<A NAME="IDX1023"></A>
<A NAME="IDX1024"></A>
<VAR>lval</VAR> is customarily accessed with the <CODE>SET_DEST</CODE> macro and 
<VAR>x</VAR> with the <CODE>SET_SRC</CODE> macro.

<A NAME="IDX1025"></A>
<DT><CODE>(return)</CODE>
<DD>
As the sole expression in a pattern, represents a return from the
current function, on machines where this can be done with one
instruction, such as Vaxes.  On machines where a multi-instruction
"epilogue" must be executed in order to return from the function,
returning is done by jumping to a label which precedes the epilogue, and
the <CODE>return</CODE> expression code is never used.

Inside an <CODE>if_then_else</CODE> expression, represents the value to be
placed in <CODE>pc</CODE> to return to the caller.

Note that an insn pattern of <CODE>(return)</CODE> is logically equivalent to
<CODE>(set (pc) (return))</CODE>, but the latter form is never used.

<A NAME="IDX1026"></A>
<DT><CODE>(call <VAR>function</VAR> <VAR>nargs</VAR>)</CODE>
<DD>
Represents a function call.  <VAR>function</VAR> is a <CODE>mem</CODE> expression
whose address is the address of the function to be called.
<VAR>nargs</VAR> is an expression which can be used for two purposes: on
some machines it represents the number of bytes of stack argument; on
others, it represents the number of argument registers.

Each machine has a standard machine mode which <VAR>function</VAR> must
have.  The machine description defines macro <CODE>FUNCTION_MODE</CODE> to
expand into the requisite mode name.  The purpose of this mode is to
specify what kind of addressing is allowed, on machines where the
allowed kinds of addressing depend on the machine mode being
addressed.

<A NAME="IDX1027"></A>
<DT><CODE>(clobber <VAR>x</VAR>)</CODE>
<DD>
Represents the storing or possible storing of an unpredictable,
undescribed value into <VAR>x</VAR>, which must be a <CODE>reg</CODE>,
<CODE>scratch</CODE> or <CODE>mem</CODE> expression.

One place this is used is in string instructions that store standard
values into particular hard registers.  It may not be worth the
trouble to describe the values that are stored, but it is essential to
inform the compiler that the registers will be altered, lest it
attempt to keep data in them across the string instruction.

If <VAR>x</VAR> is <CODE>(mem:BLK (const_int 0))</CODE>, it means that all memory
locations must be presumed clobbered.

Note that the machine description classifies certain hard registers as
"call-clobbered".  All function call instructions are assumed by
default to clobber these registers, so there is no need to use
<CODE>clobber</CODE> expressions to indicate this fact.  Also, each function
call is assumed to have the potential to alter any memory location,
unless the function is declared <CODE>const</CODE>.

If the last group of expressions in a <CODE>parallel</CODE> are each a
<CODE>clobber</CODE> expression whose arguments are <CODE>reg</CODE> or
<CODE>match_scratch</CODE> (see section <A HREF="gcc_16.html#SEC172">RTL Template</A>) expressions, the combiner
phase can add the appropriate <CODE>clobber</CODE> expressions to an insn it
has constructed when doing so will cause a pattern to be matched.

This feature can be used, for example, on a machine that whose multiply
and add instructions don't use an MQ register but which has an
add-accumulate instruction that does clobber the MQ register.  Similarly,
a combined instruction might require a temporary register while the
constituent instructions might not.

When a <CODE>clobber</CODE> expression for a register appears inside a
<CODE>parallel</CODE> with other side effects, the register allocator
guarantees that the register is unoccupied both before and after that
insn.  However, the reload phase may allocate a register used for one of
the inputs unless the <SAMP>`&#38;'</SAMP> constraint is specified for the selected
alternative (see section <A HREF="gcc_16.html#SEC179">Constraint Modifier Characters</A>).  You can clobber either a specific hard
register, a pseudo register, or a <CODE>scratch</CODE> expression; in the
latter two cases, GNU CC will allocate a hard register that is available
there for use as a temporary.

For instructions that require a temporary register, you should use
<CODE>scratch</CODE> instead of a pseudo-register because this will allow the
combiner phase to add the <CODE>clobber</CODE> when required.  You do this by
coding (<CODE>clobber</CODE> (<CODE>match_scratch</CODE> ...)).  If you do
clobber a pseudo register, use one which appears nowhere else--generate
a new one each time.  Otherwise, you may confuse CSE.

There is one other known use for clobbering a pseudo register in a
<CODE>parallel</CODE>: when one of the input operands of the insn is also
clobbered by the insn.  In this case, using the same pseudo register in
the clobber and elsewhere in the insn produces the expected results.

<A NAME="IDX1028"></A>
<DT><CODE>(use <VAR>x</VAR>)</CODE>
<DD>
Represents the use of the value of <VAR>x</VAR>.  It indicates that the
value in <VAR>x</VAR> at this point in the program is needed, even though
it may not be apparent why this is so.  Therefore, the compiler will
not attempt to delete previous instructions whose only effect is to
store a value in <VAR>x</VAR>.  <VAR>x</VAR> must be a <CODE>reg</CODE> expression.

During the reload phase, an insn that has a <CODE>use</CODE> as pattern
can carry a reg_equal note.  These <CODE>use</CODE> insns will be deleted
before the reload phase exits.

During the delayed branch scheduling phase, <VAR>x</VAR> may be an insn.
This indicates that <VAR>x</VAR> previously was located at this place in the
code and its data dependencies need to be taken into account.  These
<CODE>use</CODE> insns will be deleted before the delayed branch scheduling
phase exits.

<A NAME="IDX1029"></A>
<DT><CODE>(parallel [<VAR>x0</VAR> <VAR>x1</VAR> ...])</CODE>
<DD>
Represents several side effects performed in parallel.  The square
brackets stand for a vector; the operand of <CODE>parallel</CODE> is a
vector of expressions.  <VAR>x0</VAR>, <VAR>x1</VAR> and so on are individual
side effect expressions--expressions of code <CODE>set</CODE>, <CODE>call</CODE>,
<CODE>return</CODE>, <CODE>clobber</CODE> or <CODE>use</CODE>.
"In parallel" means that first all the values used in the individual
side-effects are computed, and second all the actual side-effects are
performed.  For example,


<PRE>
(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])
</PRE>

says unambiguously that the values of hard register 1 and the memory
location addressed by it are interchanged.  In both places where
<CODE>(reg:SI 1)</CODE> appears as a memory address it refers to the value
in register 1 <EM>before</EM> the execution of the insn.

It follows that it is <EM>incorrect</EM> to use <CODE>parallel</CODE> and
expect the result of one <CODE>set</CODE> to be available for the next one.
For example, people sometimes attempt to represent a jump-if-zero
instruction this way:


<PRE>
(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref ...)
                        (pc)))])
</PRE>

But this is incorrect, because it says that the jump condition depends
on the condition code value <EM>before</EM> this instruction, not on the
new value that is set by this instruction.

<A NAME="IDX1030"></A>
Peephole optimization, which takes place together with final assembly
code output, can produce insns whose patterns consist of a <CODE>parallel</CODE>
whose elements are the operands needed to output the resulting
assembler code--often <CODE>reg</CODE>, <CODE>mem</CODE> or constant expressions.
This would not be well-formed RTL at any other stage in compilation,
but it is ok then because no further optimization remains to be done.
However, the definition of the macro <CODE>NOTICE_UPDATE_CC</CODE>, if
any, must deal with such insns if you define any peephole optimizations.

<A NAME="IDX1031"></A>
<DT><CODE>(sequence [<VAR>insns</VAR> ...])</CODE>
<DD>
Represents a sequence of insns.  Each of the <VAR>insns</VAR> that appears
in the vector is suitable for appearing in the chain of insns, so it
must be an <CODE>insn</CODE>, <CODE>jump_insn</CODE>, <CODE>call_insn</CODE>,
<CODE>code_label</CODE>, <CODE>barrier</CODE> or <CODE>note</CODE>.

A <CODE>sequence</CODE> RTX is never placed in an actual insn during RTL
generation.  It represents the sequence of insns that result from a
<CODE>define_expand</CODE> <EM>before</EM> those insns are passed to
<CODE>emit_insn</CODE> to insert them in the chain of insns.  When actually
inserted, the individual sub-insns are separated out and the
<CODE>sequence</CODE> is forgotten.

After delay-slot scheduling is completed, an insn and all the insns that
reside in its delay slots are grouped together into a <CODE>sequence</CODE>.
The insn requiring the delay slot is the first insn in the vector;
subsequent insns are to be placed in the delay slot.

<CODE>INSN_ANNULLED_BRANCH_P</CODE> is set on an insn in a delay slot to
indicate that a branch insn should be used that will conditionally annul
the effect of the insns in the delay slots.  In such a case,
<CODE>INSN_FROM_TARGET_P</CODE> indicates that the insn is from the target of
the branch and should be executed only if the branch is taken; otherwise
the insn should be executed only if the branch is not taken.
See section <A HREF="gcc_16.html#SEC197">Delay Slot Scheduling</A>.
</DL>

<P>
These expression codes appear in place of a side effect, as the body of
an insn, though strictly speaking they do not always describe side
effects as such:

</P>
<DL COMPACT>

<DT><CODE>(asm_input <VAR>s</VAR>)</CODE>
<DD>
<A NAME="IDX1032"></A>
 
Represents literal assembler code as described by the string <VAR>s</VAR>.

<A NAME="IDX1033"></A>
<A NAME="IDX1034"></A>
<DT><CODE>(unspec [<VAR>operands</VAR> ...] <VAR>index</VAR>)</CODE>
<DD>
<DT><CODE>(unspec_volatile [<VAR>operands</VAR> ...] <VAR>index</VAR>)</CODE>
<DD>
Represents a machine-specific operation on <VAR>operands</VAR>.  <VAR>index</VAR>
selects between multiple machine-specific operations.
<CODE>unspec_volatile</CODE> is used for volatile operations and operations
that may trap; <CODE>unspec</CODE> is used for other operations.

These codes may appear inside a <CODE>pattern</CODE> of an
insn, inside a <CODE>parallel</CODE>, or inside an expression.

<A NAME="IDX1035"></A>
<DT><CODE>(addr_vec:<VAR>m</VAR> [<VAR>lr0</VAR> <VAR>lr1</VAR> ...])</CODE>
<DD>
Represents a table of jump addresses.  The vector elements <VAR>lr0</VAR>,
etc., are <CODE>label_ref</CODE> expressions.  The mode <VAR>m</VAR> specifies
how much space is given to each address; normally <VAR>m</VAR> would be
<CODE>Pmode</CODE>.

<A NAME="IDX1036"></A>
<DT><CODE>(addr_diff_vec:<VAR>m</VAR> <VAR>base</VAR> [<VAR>lr0</VAR> <VAR>lr1</VAR> ...] <VAR>min</VAR> <VAR>max</VAR> <VAR>flags</VAR>)</CODE>
<DD>
Represents a table of jump addresses expressed as offsets from
<VAR>base</VAR>.  The vector elements <VAR>lr0</VAR>, etc., are <CODE>label_ref</CODE>
expressions and so is <VAR>base</VAR>.  The mode <VAR>m</VAR> specifies how much
space is given to each address-difference.  <VAR>min</VAR> and <VAR>max</VAR>
are set up by branch shortening and hold a label with a minimum and a
maximum address, respectively.  <VAR>flags</VAR> indicates the relative
position of <VAR>base</VAR>, <VAR>min</VAR> and <VAR>max</VAR> to the cointaining insn
and of <VAR>min</VAR> and <VAR>max</VAR> to <VAR>base</VAR>.  See rtl.def for details.</DL>



<H2><A NAME="SEC163" HREF="gcc_toc.html#TOC163">Embedded Side-Effects on Addresses</A></H2>
<P>
<A NAME="IDX1037"></A>
<A NAME="IDX1038"></A>
<A NAME="IDX1039"></A>
<A NAME="IDX1040"></A>

</P>
<P>
Six special side-effect expression codes appear as memory addresses.

</P>
<DL COMPACT>

<DT><CODE>(pre_dec:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
<A NAME="IDX1041"></A>
 
Represents the side effect of decrementing <VAR>x</VAR> by a standard
amount and represents also the value that <VAR>x</VAR> has after being
decremented.  <VAR>x</VAR> must be a <CODE>reg</CODE> or <CODE>mem</CODE>, but most
machines allow only a <CODE>reg</CODE>.  <VAR>m</VAR> must be the machine mode
for pointers on the machine in use.  The amount <VAR>x</VAR> is decremented
by is the length in bytes of the machine mode of the containing memory
reference of which this expression serves as the address.  Here is an
example of its use:

<PRE>
(mem:DF (pre_dec:SI (reg:SI 39)))
</PRE>

This says to decrement pseudo register 39 by the length of a <CODE>DFmode</CODE>
value and use the result to address a <CODE>DFmode</CODE> value.

<A NAME="IDX1042"></A>
<DT><CODE>(pre_inc:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Similar, but specifies incrementing <VAR>x</VAR> instead of decrementing it.

<A NAME="IDX1043"></A>
<DT><CODE>(post_dec:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Represents the same side effect as <CODE>pre_dec</CODE> but a different
value.  The value represented here is the value <VAR>x</VAR> has <I>before</I>
being decremented.

<A NAME="IDX1044"></A>
<DT><CODE>(post_inc:<VAR>m</VAR> <VAR>x</VAR>)</CODE>
<DD>
Similar, but specifies incrementing <VAR>x</VAR> instead of decrementing it.

<A NAME="IDX1045"></A>
<DT><CODE>(post_modify:<VAR>m</VAR> <VAR>x</VAR> <VAR>y</VAR>)</CODE>
<DD>
Represents the side effect of setting <VAR>x</VAR> to <VAR>y</VAR> and
represents <VAR>x</VAR> before <VAR>x</VAR> is modified.  <VAR>x</VAR> must be a
<CODE>reg</CODE> or <CODE>mem</CODE>, but most machines allow only a <CODE>reg</CODE>.
<VAR>m</VAR> must be the machine mode for pointers on the machine in use.
The amount <VAR>x</VAR> is decremented by is the length in bytes of the
machine mode of the containing memory reference of which this expression
serves as the address.  Note that this is not currently implemented.

The expression <VAR>y</VAR> must be one of three forms:
<DL COMPACT>

<CODE>(plus:<VAR>m</VAR> <VAR>x</VAR> <VAR>z</VAR>)</CODE>,
<CODE>(minus:<VAR>m</VAR> <VAR>x</VAR> <VAR>z</VAR>)</CODE>, or
<CODE>(plus:<VAR>m</VAR> <VAR>x</VAR> <VAR>i</VAR>)</CODE>,
</DL>
where <VAR>z</VAR> is an index register and <VAR>i</VAR> is a constant.

Here is an example of its use:

<PRE>
(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42) (reg:SI 48))))
</PRE>

This says to modify pseudo register 42 by adding the contents of pseudo
register 48 to it, after the use of what ever 42 points to.

<A NAME="IDX1046"></A>
<DT><CODE>(pre_modify:<VAR>m</VAR> <VAR>x</VAR> <VAR>expr</VAR>)</CODE>
<DD>
Similar except side effects happen before the use.
</DL>

<P>
These embedded side effect expressions must be used with care.  Instruction
patterns may not use them.  Until the <SAMP>`flow'</SAMP> pass of the compiler,
they may occur only to represent pushes onto the stack.  The <SAMP>`flow'</SAMP>
pass finds cases where registers are incremented or decremented in one
instruction and used as an address shortly before or after; these cases are
then transformed to use pre- or post-increment or -decrement.

</P>
<P>
If a register used as the operand of these expressions is used in
another address in an insn, the original value of the register is used.
Uses of the register outside of an address are not permitted within the
same insn as a use in an embedded side effect expression because such
insns behave differently on different machines and hence must be treated
as ambiguous and disallowed.

</P>
<P>
An instruction that can be represented with an embedded side effect
could also be represented using <CODE>parallel</CODE> containing an additional
<CODE>set</CODE> to describe how the address register is altered.  This is not
done because machines that allow these operations at all typically
allow them wherever a memory address is called for.  Describing them as
additional parallel stores would require doubling the number of entries
in the machine description.

</P>


<H2><A NAME="SEC164" HREF="gcc_toc.html#TOC164">Assembler Instructions as Expressions</A></H2>
<P>
<A NAME="IDX1047"></A>

</P>
<P>
<A NAME="IDX1048"></A>
The RTX code <CODE>asm_operands</CODE> represents a value produced by a
user-specified assembler instruction.  It is used to represent
an <CODE>asm</CODE> statement with arguments.  An <CODE>asm</CODE> statement with
a single output operand, like this:

</P>

<PRE>
asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));
</PRE>

<P>
is represented using a single <CODE>asm_operands</CODE> RTX which represents
the value that is stored in <CODE>outputvar</CODE>:

</P>

<PRE>
(set <VAR>rtx-for-outputvar</VAR>
     (asm_operands "foo %1,%2,%0" "a" 0
                   [<VAR>rtx-for-addition-result</VAR> <VAR>rtx-for-*z</VAR>]
                   [(asm_input:<VAR>m1</VAR> "g")
                    (asm_input:<VAR>m2</VAR> "di")]))
</PRE>

<P>
Here the operands of the <CODE>asm_operands</CODE> RTX are the assembler
template string, the output-operand's constraint, the index-number of the
output operand among the output operands specified, a vector of input
operand RTX's, and a vector of input-operand modes and constraints.  The
mode <VAR>m1</VAR> is the mode of the sum <CODE>x+y</CODE>; <VAR>m2</VAR> is that of
<CODE>*z</CODE>.

</P>
<P>
When an <CODE>asm</CODE> statement has multiple output values, its insn has
several such <CODE>set</CODE> RTX's inside of a <CODE>parallel</CODE>.  Each <CODE>set</CODE>
contains a <CODE>asm_operands</CODE>; all of these share the same assembler
template and vectors, but each contains the constraint for the respective
output operand.  They are also distinguished by the output-operand index
number, which is 0, 1, ... for successive output operands.

</P>


<H2><A NAME="SEC165" HREF="gcc_toc.html#TOC165">Insns</A></H2>
<P>
<A NAME="IDX1049"></A>

</P>
<P>
The RTL representation of the code for a function is a doubly-linked
chain of objects called <STRONG>insns</STRONG>.  Insns are expressions with
special codes that are used for no other purpose.  Some insns are
actual instructions; others represent dispatch tables for <CODE>switch</CODE>
statements; others represent labels to jump to or various sorts of
declarative information.

</P>
<P>
In addition to its own specific data, each insn must have a unique
id-number that distinguishes it from all other insns in the current
function (after delayed branch scheduling, copies of an insn with the
same id-number may be present in multiple places in a function, but
these copies will always be identical and will only appear inside a
<CODE>sequence</CODE>), and chain pointers to the preceding and following
insns.  These three fields occupy the same position in every insn,
independent of the expression code of the insn.  They could be accessed
with <CODE>XEXP</CODE> and <CODE>XINT</CODE>, but instead three special macros are
always used:

</P>
<DL COMPACT>

<DT><CODE>INSN_UID (<VAR>i</VAR>)</CODE>
<DD>
<A NAME="IDX1050"></A>
 
Accesses the unique id of insn <VAR>i</VAR>.

<A NAME="IDX1051"></A>
<DT><CODE>PREV_INSN (<VAR>i</VAR>)</CODE>
<DD>
Accesses the chain pointer to the insn preceding <VAR>i</VAR>.
If <VAR>i</VAR> is the first insn, this is a null pointer.

<A NAME="IDX1052"></A>
<DT><CODE>NEXT_INSN (<VAR>i</VAR>)</CODE>
<DD>
Accesses the chain pointer to the insn following <VAR>i</VAR>.
If <VAR>i</VAR> is the last insn, this is a null pointer.
</DL>

<P>
<A NAME="IDX1053"></A>
<A NAME="IDX1054"></A>
The first insn in the chain is obtained by calling <CODE>get_insns</CODE>; the
last insn is the result of calling <CODE>get_last_insn</CODE>.  Within the
chain delimited by these insns, the <CODE>NEXT_INSN</CODE> and
<CODE>PREV_INSN</CODE> pointers must always correspond: if <VAR>insn</VAR> is not
the first insn,

</P>

<PRE>
NEXT_INSN (PREV_INSN (<VAR>insn</VAR>)) == <VAR>insn</VAR>
</PRE>

<P>
is always true and if <VAR>insn</VAR> is not the last insn,

</P>

<PRE>
PREV_INSN (NEXT_INSN (<VAR>insn</VAR>)) == <VAR>insn</VAR>
</PRE>

<P>
is always true.

</P>
<P>
After delay slot scheduling, some of the insns in the chain might be
<CODE>sequence</CODE> expressions, which contain a vector of insns.  The value
of <CODE>NEXT_INSN</CODE> in all but the last of these insns is the next insn
in the vector; the value of <CODE>NEXT_INSN</CODE> of the last insn in the vector
is the same as the value of <CODE>NEXT_INSN</CODE> for the <CODE>sequence</CODE> in
which it is contained.  Similar rules apply for <CODE>PREV_INSN</CODE>.

</P>
<P>
This means that the above invariants are not necessarily true for insns
inside <CODE>sequence</CODE> expressions.  Specifically, if <VAR>insn</VAR> is the
first insn in a <CODE>sequence</CODE>, <CODE>NEXT_INSN (PREV_INSN (<VAR>insn</VAR>))</CODE>
is the insn containing the <CODE>sequence</CODE> expression, as is the value
of <CODE>PREV_INSN (NEXT_INSN (<VAR>insn</VAR>))</CODE> is <VAR>insn</VAR> is the last
insn in the <CODE>sequence</CODE> expression.  You can use these expressions
to find the containing <CODE>sequence</CODE> expression.
</P>
<P>
Every insn has one of the following six expression codes:

</P>
<DL COMPACT>

<DT><CODE>insn</CODE>
<DD>
<A NAME="IDX1055"></A>
 
The expression code <CODE>insn</CODE> is used for instructions that do not jump
and do not do function calls.  <CODE>sequence</CODE> expressions are always
contained in insns with code <CODE>insn</CODE> even if one of those insns
should jump or do function calls.

Insns with code <CODE>insn</CODE> have four additional fields beyond the three
mandatory ones listed above.  These four are described in a table below.

<A NAME="IDX1056"></A>
<DT><CODE>jump_insn</CODE>
<DD>
The expression code <CODE>jump_insn</CODE> is used for instructions that may
jump (or, more generally, may contain <CODE>label_ref</CODE> expressions).  If
there is an instruction to return from the current function, it is
recorded as a <CODE>jump_insn</CODE>.

<A NAME="IDX1057"></A>
<CODE>jump_insn</CODE> insns have the same extra fields as <CODE>insn</CODE> insns,
accessed in the same way and in addition contain a field
<CODE>JUMP_LABEL</CODE> which is defined once jump optimization has completed.

For simple conditional and unconditional jumps, this field contains the
<CODE>code_label</CODE> to which this insn will (possibly conditionally)
branch.  In a more complex jump, <CODE>JUMP_LABEL</CODE> records one of the
labels that the insn refers to; the only way to find the others
is to scan the entire body of the insn.

Return insns count as jumps, but since they do not refer to any labels,
they have zero in the <CODE>JUMP_LABEL</CODE> field.

<A NAME="IDX1058"></A>
<DT><CODE>call_insn</CODE>
<DD>
The expression code <CODE>call_insn</CODE> is used for instructions that may do
function calls.  It is important to distinguish these instructions because
they imply that certain registers and memory locations may be altered
unpredictably.

<A NAME="IDX1059"></A>
<CODE>call_insn</CODE> insns have the same extra fields as <CODE>insn</CODE> insns,
accessed in the same way and in addition contain a field
<CODE>CALL_INSN_FUNCTION_USAGE</CODE>, which contains a list (chain of
<CODE>expr_list</CODE> expressions) containing <CODE>use</CODE> and <CODE>clobber</CODE>
expressions that denote hard registers used or clobbered by the called
function.  A register specified in a <CODE>clobber</CODE> in this list is
modified <EM>after</EM> the execution of the <CODE>call_insn</CODE>, while a
register in a <CODE>clobber</CODE> in the body of the <CODE>call_insn</CODE> is
clobbered before the insn completes execution.  <CODE>clobber</CODE>
expressions in this list augment registers specified in
<CODE>CALL_USED_REGISTERS</CODE> (see section <A HREF="gcc_17.html#SEC205">Basic Characteristics of Registers</A>).

<A NAME="IDX1060"></A>
<A NAME="IDX1061"></A>
<DT><CODE>code_label</CODE>
<DD>
A <CODE>code_label</CODE> insn represents a label that a jump insn can jump
to.  It contains two special fields of data in addition to the three
standard ones.  <CODE>CODE_LABEL_NUMBER</CODE> is used to hold the <STRONG>label
number</STRONG>, a number that identifies this label uniquely among all the
labels in the compilation (not just in the current function).
Ultimately, the label is represented in the assembler output as an
assembler label, usually of the form <SAMP>`L<VAR>n</VAR>'</SAMP> where <VAR>n</VAR> is
the label number.

When a <CODE>code_label</CODE> appears in an RTL expression, it normally
appears within a <CODE>label_ref</CODE> which represents the address of
the label, as a number.

<A NAME="IDX1062"></A>
The field <CODE>LABEL_NUSES</CODE> is only defined once the jump optimization
phase is completed and contains the number of times this label is
referenced in the current function.

<A NAME="IDX1063"></A>
<DT><CODE>barrier</CODE>
<DD>
Barriers are placed in the instruction stream when control cannot flow
past them.  They are placed after unconditional jump instructions to
indicate that the jumps are unconditional and after calls to
<CODE>volatile</CODE> functions, which do not return (e.g., <CODE>exit</CODE>).
They contain no information beyond the three standard fields.

<A NAME="IDX1064"></A>
<A NAME="IDX1065"></A>
<A NAME="IDX1066"></A>
<DT><CODE>note</CODE>
<DD>
<CODE>note</CODE> insns are used to represent additional debugging and
declarative information.  They contain two nonstandard fields, an
integer which is accessed with the macro <CODE>NOTE_LINE_NUMBER</CODE> and a
string accessed with <CODE>NOTE_SOURCE_FILE</CODE>.

If <CODE>NOTE_LINE_NUMBER</CODE> is positive, the note represents the
position of a source line and <CODE>NOTE_SOURCE_FILE</CODE> is the source file name
that the line came from.  These notes control generation of line
number data in the assembler output.

Otherwise, <CODE>NOTE_LINE_NUMBER</CODE> is not really a line number but a
code with one of the following values (and <CODE>NOTE_SOURCE_FILE</CODE>
must contain a null pointer):

<DL COMPACT>

<DT><CODE>NOTE_INSN_DELETED</CODE>
<DD>
<A NAME="IDX1067"></A>
 
Such a note is completely ignorable.  Some passes of the compiler
delete insns by altering them into notes of this kind.

<A NAME="IDX1068"></A>
<A NAME="IDX1069"></A>
<DT><CODE>NOTE_INSN_BLOCK_BEG</CODE>
<DD>
<DT><CODE>NOTE_INSN_BLOCK_END</CODE>
<DD>
These types of notes indicate the position of the beginning and end
of a level of scoping of variable names.  They control the output
of debugging information.

<A NAME="IDX1070"></A>
<A NAME="IDX1071"></A>
<DT><CODE>NOTE_INSN_EH_REGION_BEG</CODE>
<DD>
<DT><CODE>NOTE_INSN_EH_REGION_END</CODE>
<DD>
These types of notes indicate the position of the beginning and end of a
level of scoping for exception handling.  <CODE>NOTE_BLOCK_NUMBER</CODE>
identifies which <CODE>CODE_LABEL</CODE> is associated with the given region.

<A NAME="IDX1072"></A>
<A NAME="IDX1073"></A>
<DT><CODE>NOTE_INSN_LOOP_BEG</CODE>
<DD>
<DT><CODE>NOTE_INSN_LOOP_END</CODE>
<DD>
These types of notes indicate the position of the beginning and end
of a <CODE>while</CODE> or <CODE>for</CODE> loop.  They enable the loop optimizer
to find loops quickly.

<A NAME="IDX1074"></A>
<DT><CODE>NOTE_INSN_LOOP_CONT</CODE>
<DD>
Appears at the place in a loop that <CODE>continue</CODE> statements jump to.

<A NAME="IDX1075"></A>
<DT><CODE>NOTE_INSN_LOOP_VTOP</CODE>
<DD>
This note indicates the place in a loop where the exit test begins for
those loops in which the exit test has been duplicated.  This position
becomes another virtual start of the loop when considering loop
invariants. 

<A NAME="IDX1076"></A>
<DT><CODE>NOTE_INSN_FUNCTION_END</CODE>
<DD>
Appears near the end of the function body, just before the label that
<CODE>return</CODE> statements jump to (on machine where a single instruction
does not suffice for returning).  This note may be deleted by jump
optimization.

<A NAME="IDX1077"></A>
<DT><CODE>NOTE_INSN_SETJMP</CODE>
<DD>
Appears following each call to <CODE>setjmp</CODE> or a related function.
</DL>

These codes are printed symbolically when they appear in debugging dumps.
</DL>

<P>
<A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>
<A NAME="IDX1080"></A>
The machine mode of an insn is normally <CODE>VOIDmode</CODE>, but some
phases use the mode for various purposes. 

</P>
<P>
The common subexpression elimination pass sets the mode of an insn to
<CODE>QImode</CODE> when it is the first insn in a block that has already
been processed.

</P>
<P>
The second Haifa scheduling pass, for targets that can multiple issue,
sets the mode of an insn to <CODE>TImode</CODE> when it is believed that the
instruction begins an issue group.  That is, when the instruction 
cannot issue simultaneously with the previous.  This may be relied on
by later passes, in particular machine-dependant reorg.

</P>
<P>
Here is a table of the extra fields of <CODE>insn</CODE>, <CODE>jump_insn</CODE>
and <CODE>call_insn</CODE> insns:

</P>
<DL COMPACT>

<DT><CODE>PATTERN (<VAR>i</VAR>)</CODE>
<DD>
<A NAME="IDX1081"></A>
 
An expression for the side effect performed by this insn.  This must be
one of the following codes: <CODE>set</CODE>, <CODE>call</CODE>, <CODE>use</CODE>,
<CODE>clobber</CODE>, <CODE>return</CODE>, <CODE>asm_input</CODE>, <CODE>asm_output</CODE>,
<CODE>addr_vec</CODE>, <CODE>addr_diff_vec</CODE>, <CODE>trap_if</CODE>, <CODE>unspec</CODE>,
<CODE>unspec_volatile</CODE>, <CODE>parallel</CODE>, or <CODE>sequence</CODE>.  If it is a <CODE>parallel</CODE>,
each element of the <CODE>parallel</CODE> must be one these codes, except that
<CODE>parallel</CODE> expressions cannot be nested and <CODE>addr_vec</CODE> and
<CODE>addr_diff_vec</CODE> are not permitted inside a <CODE>parallel</CODE> expression.

<A NAME="IDX1082"></A>
<DT><CODE>INSN_CODE (<VAR>i</VAR>)</CODE>
<DD>
An integer that says which pattern in the machine description matches
this insn, or -1 if the matching has not yet been attempted.

Such matching is never attempted and this field remains -1 on an insn
whose pattern consists of a single <CODE>use</CODE>, <CODE>clobber</CODE>,
<CODE>asm_input</CODE>, <CODE>addr_vec</CODE> or <CODE>addr_diff_vec</CODE> expression.

<A NAME="IDX1083"></A>
Matching is also never attempted on insns that result from an <CODE>asm</CODE>
statement.  These contain at least one <CODE>asm_operands</CODE> expression.
The function <CODE>asm_noperands</CODE> returns a non-negative value for
such insns.

In the debugging output, this field is printed as a number followed by
a symbolic representation that locates the pattern in the <TT>`md'</TT>
file as some small positive or negative offset from a named pattern.

<A NAME="IDX1084"></A>
<DT><CODE>LOG_LINKS (<VAR>i</VAR>)</CODE>
<DD>
A list (chain of <CODE>insn_list</CODE> expressions) giving information about
dependencies between instructions within a basic block.  Neither a jump
nor a label may come between the related insns.

<A NAME="IDX1085"></A>
<DT><CODE>REG_NOTES (<VAR>i</VAR>)</CODE>
<DD>
A list (chain of <CODE>expr_list</CODE> and <CODE>insn_list</CODE> expressions)
giving miscellaneous information about the insn.  It is often
information pertaining to the registers used in this insn.
</DL>

<P>
The <CODE>LOG_LINKS</CODE> field of an insn is a chain of <CODE>insn_list</CODE>
expressions.  Each of these has two operands: the first is an insn,
and the second is another <CODE>insn_list</CODE> expression (the next one in
the chain).  The last <CODE>insn_list</CODE> in the chain has a null pointer
as second operand.  The significant thing about the chain is which
insns appear in it (as first operands of <CODE>insn_list</CODE>
expressions).  Their order is not significant.

</P>
<P>
This list is originally set up by the flow analysis pass; it is a null
pointer until then.  Flow only adds links for those data dependencies
which can be used for instruction combination.  For each insn, the flow
analysis pass adds a link to insns which store into registers values
that are used for the first time in this insn.  The instruction
scheduling pass adds extra links so that every dependence will be
represented.  Links represent data dependencies, antidependencies and
output dependencies; the machine mode of the link distinguishes these
three types: antidependencies have mode <CODE>REG_DEP_ANTI</CODE>, output
dependencies have mode <CODE>REG_DEP_OUTPUT</CODE>, and data dependencies have
mode <CODE>VOIDmode</CODE>.

</P>
<P>
The <CODE>REG_NOTES</CODE> field of an insn is a chain similar to the
<CODE>LOG_LINKS</CODE> field but it includes <CODE>expr_list</CODE> expressions in
addition to <CODE>insn_list</CODE> expressions.  There are several kinds of
register notes, which are distinguished by the machine mode, which in a
register note is really understood as being an <CODE>enum reg_note</CODE>.
The first operand <VAR>op</VAR> of the note is data whose meaning depends on
the kind of note.

</P>
<P>
<A NAME="IDX1086"></A>
<A NAME="IDX1087"></A>
The macro <CODE>REG_NOTE_KIND (<VAR>x</VAR>)</CODE> returns the kind of
register note.  Its counterpart, the macro <CODE>PUT_REG_NOTE_KIND
(<VAR>x</VAR>, <VAR>newkind</VAR>)</CODE> sets the register note type of <VAR>x</VAR> to be
<VAR>newkind</VAR>.

</P>
<P>
Register notes are of three classes: They may say something about an
input to an insn, they may say something about an output of an insn, or
they may create a linkage between two insns.  There are also a set
of values that are only used in <CODE>LOG_LINKS</CODE>.

</P>
<P>
These register notes annotate inputs to an insn:

</P>
<DL COMPACT>

<DT><CODE>REG_DEAD</CODE>
<DD>
<A NAME="IDX1088"></A>
 
The value in <VAR>op</VAR> dies in this insn; that is to say, altering the
value immediately after this insn would not affect the future behavior
of the program.  

This does not necessarily mean that the register <VAR>op</VAR> has no useful
value after this insn since it may also be an output of the insn.  In
such a case, however, a <CODE>REG_DEAD</CODE> note would be redundant and is
usually not present until after the reload pass, but no code relies on
this fact.

<A NAME="IDX1089"></A>
<DT><CODE>REG_INC</CODE>
<DD>
The register <VAR>op</VAR> is incremented (or decremented; at this level
there is no distinction) by an embedded side effect inside this insn.
This means it appears in a <CODE>post_inc</CODE>, <CODE>pre_inc</CODE>,
<CODE>post_dec</CODE> or <CODE>pre_dec</CODE> expression.

<A NAME="IDX1090"></A>
<DT><CODE>REG_NONNEG</CODE>
<DD>
The register <VAR>op</VAR> is known to have a nonnegative value when this
insn is reached.  This is used so that decrement and branch until zero
instructions, such as the m68k dbra, can be matched.

The <CODE>REG_NONNEG</CODE> note is added to insns only if the machine
description has a <SAMP>`decrement_and_branch_until_zero'</SAMP> pattern.

<A NAME="IDX1091"></A>
<DT><CODE>REG_NO_CONFLICT</CODE>
<DD>
This insn does not cause a conflict between <VAR>op</VAR> and the item
being set by this insn even though it might appear that it does.
In other words, if the destination register and <VAR>op</VAR> could
otherwise be assigned the same register, this insn does not
prevent that assignment.

Insns with this note are usually part of a block that begins with a
<CODE>clobber</CODE> insn specifying a multi-word pseudo register (which will
be the output of the block), a group of insns that each set one word of
the value and have the <CODE>REG_NO_CONFLICT</CODE> note attached, and a final
insn that copies the output to itself with an attached <CODE>REG_EQUAL</CODE>
note giving the expression being computed.  This block is encapsulated
with <CODE>REG_LIBCALL</CODE> and <CODE>REG_RETVAL</CODE> notes on the first and
last insns, respectively.

<A NAME="IDX1092"></A>
<DT><CODE>REG_LABEL</CODE>
<DD>
This insn uses <VAR>op</VAR>, a <CODE>code_label</CODE>, but is not a
<CODE>jump_insn</CODE>.  The presence of this note allows jump optimization to
be aware that <VAR>op</VAR> is, in fact, being used.
</DL>

<P>
The following notes describe attributes of outputs of an insn:

</P>
<DL COMPACT>

<DT><CODE>REG_EQUIV</CODE>
<DD>
<A NAME="IDX1093"></A>
 <A NAME="IDX1094"></A>
 
<DT><CODE>REG_EQUAL</CODE>
<DD>
This note is only valid on an insn that sets only one register and
indicates that that register will be equal to <VAR>op</VAR> at run time; the
scope of this equivalence differs between the two types of notes.  The
value which the insn explicitly copies into the register may look
different from <VAR>op</VAR>, but they will be equal at run time.  If the
output of the single <CODE>set</CODE> is a <CODE>strict_low_part</CODE> expression,
the note refers to the register that is contained in <CODE>SUBREG_REG</CODE>
of the <CODE>subreg</CODE> expression.
 
For <CODE>REG_EQUIV</CODE>, the register is equivalent to <VAR>op</VAR> throughout
the entire function, and could validly be replaced in all its
occurrences by <VAR>op</VAR>.  ("Validly" here refers to the data flow of
the program; simple replacement may make some insns invalid.)  For
example, when a constant is loaded into a register that is never
assigned any other value, this kind of note is used.

When a parameter is copied into a pseudo-register at entry to a function,
a note of this kind records that the register is equivalent to the stack
slot where the parameter was passed.  Although in this case the register
may be set by other insns, it is still valid to replace the register
by the stack slot throughout the function.

A <CODE>REG_EQUIV</CODE> note is also used on an instruction which copies a
register parameter into a pseudo-register at entry to a function, if
there is a stack slot where that parameter could be stored.  Although
other insns may set the pseudo-register, it is valid for the compiler to
replace the pseudo-register by stack slot throughout the function,
provided the compiler ensures that the stack slot is properly
initialized by making the replacement in the initial copy instruction as
well.  This is used on machines for which the calling convention
allocates stack space for register parameters.  See
<CODE>REG_PARM_STACK_SPACE</CODE> in section <A HREF="gcc_17.html#SEC217">Passing Function Arguments on the Stack</A>.

In the case of <CODE>REG_EQUAL</CODE>, the register that is set by this insn
will be equal to <VAR>op</VAR> at run time at the end of this insn but not
necessarily elsewhere in the function.  In this case, <VAR>op</VAR>
is typically an arithmetic expression.  For example, when a sequence of
insns such as a library call is used to perform an arithmetic operation,
this kind of note is attached to the insn that produces or copies the
final value.

These two notes are used in different ways by the compiler passes.
<CODE>REG_EQUAL</CODE> is used by passes prior to register allocation (such as
common subexpression elimination and loop optimization) to tell them how
to think of that value.  <CODE>REG_EQUIV</CODE> notes are used by register
allocation to indicate that there is an available substitute expression
(either a constant or a <CODE>mem</CODE> expression for the location of a
parameter on the stack) that may be used in place of a register if
insufficient registers are available.

Except for stack homes for parameters, which are indicated by a
<CODE>REG_EQUIV</CODE> note and are not useful to the early optimization
passes and pseudo registers that are equivalent to a memory location
throughout there entire life, which is not detected until later in
the compilation, all equivalences are initially indicated by an attached
<CODE>REG_EQUAL</CODE> note.  In the early stages of register allocation, a
<CODE>REG_EQUAL</CODE> note is changed into a <CODE>REG_EQUIV</CODE> note if
<VAR>op</VAR> is a constant and the insn represents the only set of its
destination register.

Thus, compiler passes prior to register allocation need only check for
<CODE>REG_EQUAL</CODE> notes and passes subsequent to register allocation
need only check for <CODE>REG_EQUIV</CODE> notes.

<A NAME="IDX1095"></A>
<DT><CODE>REG_UNUSED</CODE>
<DD>
The register <VAR>op</VAR> being set by this insn will not be used in a
subsequent insn.  This differs from a <CODE>REG_DEAD</CODE> note, which
indicates that the value in an input will not be used subsequently.
These two notes are independent; both may be present for the same
register.

<A NAME="IDX1096"></A>
<DT><CODE>REG_WAS_0</CODE>
<DD>
The single output of this insn contained zero before this insn.
<VAR>op</VAR> is the insn that set it to zero.  You can rely on this note if
it is present and <VAR>op</VAR> has not been deleted or turned into a <CODE>note</CODE>;
its absence implies nothing.
</DL>

<P>
These notes describe linkages between insns.  They occur in pairs: one
insn has one of a pair of notes that points to a second insn, which has
the inverse note pointing back to the first insn.

</P>
<DL COMPACT>

<DT><CODE>REG_RETVAL</CODE>
<DD>
<A NAME="IDX1097"></A>
 
This insn copies the value of a multi-insn sequence (for example, a
library call), and <VAR>op</VAR> is the first insn of the sequence (for a
library call, the first insn that was generated to set up the arguments
for the library call).

Loop optimization uses this note to treat such a sequence as a single
operation for code motion purposes and flow analysis uses this note to
delete such sequences whose results are dead.

A <CODE>REG_EQUAL</CODE> note will also usually be attached to this insn to 
provide the expression being computed by the sequence.

These notes will be deleted after reload, since they are no longer
accurate or useful.

<A NAME="IDX1098"></A>
<DT><CODE>REG_LIBCALL</CODE>
<DD>
This is the inverse of <CODE>REG_RETVAL</CODE>: it is placed on the first
insn of a multi-insn sequence, and it points to the last one.

These notes are deleted after reload, since they are no longer useful or 
accurate.

<A NAME="IDX1099"></A>
<A NAME="IDX1100"></A>
<DT><CODE>REG_CC_SETTER</CODE>
<DD>
<DT><CODE>REG_CC_USER</CODE>
<DD>
On machines that use <CODE>cc0</CODE>, the insns which set and use <CODE>cc0</CODE>
set and use <CODE>cc0</CODE> are adjacent.  However, when branch delay slot
filling is done, this may no longer be true.  In this case a
<CODE>REG_CC_USER</CODE> note will be placed on the insn setting <CODE>cc0</CODE> to
point to the insn using <CODE>cc0</CODE> and a <CODE>REG_CC_SETTER</CODE> note will
be placed on the insn using <CODE>cc0</CODE> to point to the insn setting
<CODE>cc0</CODE>.</DL>

<P>
These values are only used in the <CODE>LOG_LINKS</CODE> field, and indicate
the type of dependency that each link represents.  Links which indicate
a data dependence (a read after write dependence) do not use any code,
they simply have mode <CODE>VOIDmode</CODE>, and are printed without any
descriptive text.

</P>
<DL COMPACT>

<DT><CODE>REG_DEP_ANTI</CODE>
<DD>
<A NAME="IDX1101"></A>
 
This indicates an anti dependence (a write after read dependence).

<A NAME="IDX1102"></A>
<DT><CODE>REG_DEP_OUTPUT</CODE>
<DD>
This indicates an output dependence (a write after write dependence).
</DL>

<P>
These notes describe information gathered from gcov profile data.  They
are stored in the <CODE>REG_NOTES</CODE> field of an insn as an
<CODE>expr_list</CODE>.

</P>
<DL COMPACT>

<DT><CODE>REG_EXEC_COUNT</CODE>
<DD>
<A NAME="IDX1103"></A>
 
This is used to indicate the number of times a basic block was executed
according to the profile data.  The note is attached to the first insn in
the basic block.

<A NAME="IDX1104"></A>
<DT><CODE>REG_BR_PROB</CODE>
<DD>
This is used to specify the ratio of branches to non-branches of a
branch insn according to the profile data.  The value is stored as a
value between 0 and REG_BR_PROB_BASE; larger values indicate a higher
probability that the branch will be taken.

<A NAME="IDX1105"></A>
<DT><CODE>REG_BR_PRED</CODE>
<DD>
These notes are found in JUMP insns after delayed branch scheduling
has taken place.  They indicate both the direction and the likelyhood
of the JUMP.  The format is a bitmask of ATTR_FLAG_* values.

<A NAME="IDX1106"></A>
<DT><CODE>REG_FRAME_RELATED_EXPR</CODE>
<DD>
This is used on an RTX_FRAME_RELATED_P insn wherein the attached expression
is used in place of the actual insn pattern.  This is done in cases where
the pattern is either complex or misleading.
</DL>

<P>
For convenience, the machine mode in an <CODE>insn_list</CODE> or
<CODE>expr_list</CODE> is printed using these symbolic codes in debugging dumps.

</P>
<P>
<A NAME="IDX1107"></A>
<A NAME="IDX1108"></A>
The only difference between the expression codes <CODE>insn_list</CODE> and
<CODE>expr_list</CODE> is that the first operand of an <CODE>insn_list</CODE> is
assumed to be an insn and is printed in debugging dumps as the insn's
unique id; the first operand of an <CODE>expr_list</CODE> is printed in the
ordinary way as an expression.

</P>


<H2><A NAME="SEC166" HREF="gcc_toc.html#TOC166">RTL Representation of Function-Call Insns</A></H2>
<P>
<A NAME="IDX1109"></A>
<A NAME="IDX1110"></A>
<A NAME="IDX1111"></A>

</P>
<P>
Insns that call subroutines have the RTL expression code <CODE>call_insn</CODE>.
These insns must satisfy special rules, and their bodies must use a special
RTL expression code, <CODE>call</CODE>.

</P>
<P>
<A NAME="IDX1112"></A>
A <CODE>call</CODE> expression has two operands, as follows:

</P>

<PRE>
(call (mem:<VAR>fm</VAR> <VAR>addr</VAR>) <VAR>nbytes</VAR>)
</PRE>

<P>
Here <VAR>nbytes</VAR> is an operand that represents the number of bytes of
argument data being passed to the subroutine, <VAR>fm</VAR> is a machine mode
(which must equal as the definition of the <CODE>FUNCTION_MODE</CODE> macro in
the machine description) and <VAR>addr</VAR> represents the address of the
subroutine.

</P>
<P>
For a subroutine that returns no value, the <CODE>call</CODE> expression as
shown above is the entire body of the insn, except that the insn might
also contain <CODE>use</CODE> or <CODE>clobber</CODE> expressions.

</P>
<P>
<A NAME="IDX1113"></A>
For a subroutine that returns a value whose mode is not <CODE>BLKmode</CODE>,
the value is returned in a hard register.  If this register's number is
<VAR>r</VAR>, then the body of the call insn looks like this:

</P>

<PRE>
(set (reg:<VAR>m</VAR> <VAR>r</VAR>)
     (call (mem:<VAR>fm</VAR> <VAR>addr</VAR>) <VAR>nbytes</VAR>))
</PRE>

<P>
This RTL expression makes it clear (to the optimizer passes) that the
appropriate register receives a useful value in this insn.

</P>
<P>
When a subroutine returns a <CODE>BLKmode</CODE> value, it is handled by
passing to the subroutine the address of a place to store the value.
So the call insn itself does not "return" any value, and it has the
same RTL form as a call that returns nothing.

</P>
<P>
On some machines, the call instruction itself clobbers some register,
for example to contain the return address.  <CODE>call_insn</CODE> insns
on these machines should have a body which is a <CODE>parallel</CODE>
that contains both the <CODE>call</CODE> expression and <CODE>clobber</CODE>
expressions that indicate which registers are destroyed.  Similarly,
if the call instruction requires some register other than the stack
pointer that is not explicitly mentioned it its RTL, a <CODE>use</CODE>
subexpression should mention that register.

</P>
<P>
Functions that are called are assumed to modify all registers listed in
the configuration macro <CODE>CALL_USED_REGISTERS</CODE> (see section <A HREF="gcc_17.html#SEC205">Basic Characteristics of Registers</A>) and, with the exception of <CODE>const</CODE> functions and library
calls, to modify all of memory.

</P>
<P>
Insns containing just <CODE>use</CODE> expressions directly precede the
<CODE>call_insn</CODE> insn to indicate which registers contain inputs to the
function.  Similarly, if registers other than those in
<CODE>CALL_USED_REGISTERS</CODE> are clobbered by the called function, insns
containing a single <CODE>clobber</CODE> follow immediately after the call to
indicate which registers.

</P>


<H2><A NAME="SEC167" HREF="gcc_toc.html#TOC167">Structure Sharing Assumptions</A></H2>
<P>
<A NAME="IDX1114"></A>
<A NAME="IDX1115"></A>

</P>
<P>
The compiler assumes that certain kinds of RTL expressions are unique;
there do not exist two distinct objects representing the same value.
In other cases, it makes an opposite assumption: that no RTL expression
object of a certain kind appears in more than one place in the
containing structure.

</P>
<P>
These assumptions refer to a single function; except for the RTL
objects that describe global variables and external functions,
and a few standard objects such as small integer constants,
no RTL objects are common to two functions.

</P>

<UL>
<LI>

<A NAME="IDX1116"></A>
 
Each pseudo-register has only a single <CODE>reg</CODE> object to represent it,
and therefore only a single machine mode.

<A NAME="IDX1117"></A>
<A NAME="IDX1118"></A>
<LI>

For any symbolic label, there is only one <CODE>symbol_ref</CODE> object
referring to it.

<A NAME="IDX1119"></A>
<LI>

There is only one <CODE>const_int</CODE> expression with value 0, only
one with value 1, and only one with value -1.
Some other integer values are also stored uniquely.

<A NAME="IDX1120"></A>
<LI>

There is only one <CODE>pc</CODE> expression.

<A NAME="IDX1121"></A>
<LI>

There is only one <CODE>cc0</CODE> expression.

<A NAME="IDX1122"></A>
<LI>

There is only one <CODE>const_double</CODE> expression with value 0 for
each floating point mode.  Likewise for values 1 and 2.

<A NAME="IDX1123"></A>
<A NAME="IDX1124"></A>
<LI>

No <CODE>label_ref</CODE> or <CODE>scratch</CODE> appears in more than one place in
the RTL structure; in other words, it is safe to do a tree-walk of all
the insns in the function and assume that each time a <CODE>label_ref</CODE>
or <CODE>scratch</CODE> is seen it is distinct from all others that are seen.

<A NAME="IDX1125"></A>
<LI>

Only one <CODE>mem</CODE> object is normally created for each static
variable or stack slot, so these objects are frequently shared in all
the places they appear.  However, separate but equal objects for these
variables are occasionally made.

<A NAME="IDX1126"></A>
<LI>

When a single <CODE>asm</CODE> statement has multiple output operands, a
distinct <CODE>asm_operands</CODE> expression is made for each output operand.
However, these all share the vector which contains the sequence of input
operands.  This sharing is used later on to test whether two
<CODE>asm_operands</CODE> expressions come from the same statement, so all
optimizations must carefully preserve the sharing if they copy the
vector at all.

<LI>

No RTL object appears in more than one place in the RTL structure
except as described above.  Many passes of the compiler rely on this
by assuming that they can modify RTL objects in place without unwanted
side-effects on other insns.

<A NAME="IDX1127"></A>
<LI>

During initial RTL generation, shared structure is freely introduced.
After all the RTL for a function has been generated, all shared
structure is copied by <CODE>unshare_all_rtl</CODE> in <TT>`emit-rtl.c'</TT>,
after which the above rules are guaranteed to be followed.

<A NAME="IDX1128"></A>
<LI>

During the combiner pass, shared structure within an insn can exist
temporarily.  However, the shared structure is copied before the
combiner is finished with the insn.  This is done by calling
<CODE>copy_rtx_if_shared</CODE>, which is a subroutine of
<CODE>unshare_all_rtl</CODE>.
</UL>



<H2><A NAME="SEC168" HREF="gcc_toc.html#TOC168">Reading RTL</A></H2>

<P>
To read an RTL object from a file, call <CODE>read_rtx</CODE>.  It takes one
argument, a stdio stream, and returns a single RTL object.

</P>
<P>
Reading RTL from a file is very slow.  This is not currently a
problem since reading RTL occurs only as part of building the
compiler.

</P>
<P>
People frequently have the idea of using RTL stored as text in a file as
an interface between a language front end and the bulk of GNU CC.  This
idea is not feasible.

</P>
<P>
GNU CC was designed to use RTL internally only.  Correct RTL for a given
program is very dependent on the particular target machine.  And the RTL
does not contain all the information about the program.

</P>
<P>
The proper way to interface GNU CC to a new language front end is with
the "tree" data structure.  There is no manual for this data
structure, but it is described in the files <TT>`tree.h'</TT> and
<TT>`tree.def'</TT>.

</P>
<P><HR><P>
<p>Go to the <A HREF="gcc_1.html">first</A>, <A HREF="gcc_14.html">previous</A>, <A HREF="gcc_16.html">next</A>, <A HREF="gcc_24.html">last</A> section, <A HREF="gcc_toc.html">table of contents</A>.
</BODY>
</HTML>
