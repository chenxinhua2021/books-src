<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from gcc.texi on 30 July 1999 -->

<TITLE>Using and Porting GNU CC - Passes and Files of the Compiler</TITLE>
<link href="gcc_15.html" rel=Next>
<link href="gcc_13.html" rel=Previous>
<link href="gcc_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="gcc_1.html">first</A>, <A HREF="gcc_13.html">previous</A>, <A HREF="gcc_15.html">next</A>, <A HREF="gcc_24.html">last</A> section, <A HREF="gcc_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC148" HREF="gcc_toc.html#TOC148">Passes and Files of the Compiler</A></H1>
<P>
<A NAME="IDX643"></A>
<A NAME="IDX644"></A>
<A NAME="IDX645"></A>

</P>
<P>
<A NAME="IDX646"></A>
The overall control structure of the compiler is in <TT>`toplev.c'</TT>.  This
file is responsible for initialization, decoding arguments, opening and
closing files, and sequencing the passes.

</P>
<P>
<A NAME="IDX647"></A>
The parsing pass is invoked only once, to parse the entire input.  The RTL
intermediate code for a function is generated as the function is parsed, a
statement at a time.  Each statement is read in as a syntax tree and then
converted to RTL; then the storage for the tree for the statement is
reclaimed.  Storage for types (and the expressions for their sizes),
declarations, and a representation of the binding contours and how they nest,
remain until the function is finished being compiled; these are all needed
to output the debugging information.

</P>
<P>
<A NAME="IDX648"></A>
<A NAME="IDX649"></A>
Each time the parsing pass reads a complete function definition or
top-level declaration, it calls either the function
<CODE>rest_of_compilation</CODE>, or the function
<CODE>rest_of_decl_compilation</CODE> in <TT>`toplev.c'</TT>, which are
responsible for all further processing necessary, ending with output of
the assembler language.  All other compiler passes run, in sequence,
within <CODE>rest_of_compilation</CODE>.  When that function returns from
compiling a function definition, the storage used for that function
definition's compilation is entirely freed, unless it is an inline
function
(see section <A HREF="gcc_4.html#SEC92">An Inline Function is As Fast As a Macro</A>).

</P>
<P>
Here is a list of all the passes of the compiler and their source files.
Also included is a description of where debugging dumps can be requested
with <SAMP>`-d'</SAMP> options.

</P>

<UL>
<LI>

Parsing.  This pass reads the entire text of a function definition,
constructing partial syntax trees.  This and RTL generation are no longer
truly separate passes (formerly they were), but it is easier to think
of them as separate.

The tree representation does not entirely follow C syntax, because it is
intended to support other languages as well.

Language-specific data type analysis is also done in this pass, and every
tree node that represents an expression has a data type attached.
Variables are represented as declaration nodes.

<A NAME="IDX650"></A>
<A NAME="IDX651"></A>
<A NAME="IDX652"></A>
Constant folding and some arithmetic simplifications are also done
during this pass.

The language-independent source files for parsing are
<TT>`stor-layout.c'</TT>, <TT>`fold-const.c'</TT>, and <TT>`tree.c'</TT>.
There are also header files <TT>`tree.h'</TT> and <TT>`tree.def'</TT>
which define the format of the tree representation.
The source files to parse C are
<TT>`c-parse.in'</TT>,
<TT>`c-decl.c'</TT>,
<TT>`c-typeck.c'</TT>,
<TT>`c-aux-info.c'</TT>,
<TT>`c-convert.c'</TT>,
and <TT>`c-lang.c'</TT>
along with header files
<TT>`c-lex.h'</TT>, and
<TT>`c-tree.h'</TT>.

The source files for parsing C++ are <TT>`cp-parse.y'</TT>,
<TT>`cp-class.c'</TT>,<BR>
<TT>`cp-cvt.c'</TT>, <TT>`cp-decl.c'</TT>, <TT>`cp-decl2.c'</TT>,
<TT>`cp-dem.c'</TT>, <TT>`cp-except.c'</TT>,<BR>
<TT>`cp-expr.c'</TT>, <TT>`cp-init.c'</TT>, <TT>`cp-lex.c'</TT>,
<TT>`cp-method.c'</TT>, <TT>`cp-ptree.c'</TT>,<BR>
<TT>`cp-search.c'</TT>, <TT>`cp-tree.c'</TT>, <TT>`cp-type2.c'</TT>, and
<TT>`cp-typeck.c'</TT>, along with header files <TT>`cp-tree.def'</TT>,
<TT>`cp-tree.h'</TT>, and <TT>`cp-decl.h'</TT>.

The special source files for parsing Objective C are
<TT>`objc-parse.y'</TT>, <TT>`objc-actions.c'</TT>, <TT>`objc-tree.def'</TT>, and
<TT>`objc-actions.h'</TT>.  Certain C-specific files are used for this as
well.

The file <TT>`c-common.c'</TT> is also used for all of the above languages.

<A NAME="IDX653"></A>
<LI>

RTL generation.  This is the conversion of syntax tree into RTL code.
It is actually done statement-by-statement during parsing, but for
most purposes it can be thought of as a separate pass.

<A NAME="IDX654"></A>
This is where the bulk of target-parameter-dependent code is found,
since often it is necessary for strategies to apply only when certain
standard kinds of instructions are available.  The purpose of named
instruction patterns is to provide this information to the RTL
generation pass.

<A NAME="IDX655"></A>
Optimization is done in this pass for <CODE>if</CODE>-conditions that are
comparisons, boolean operations or conditional expressions.  Tail
recursion is detected at this time also.  Decisions are made about how
best to arrange loops and how to output <CODE>switch</CODE> statements.

The source files for RTL generation include
<TT>`stmt.c'</TT>,
<TT>`calls.c'</TT>,
<TT>`expr.c'</TT>,
<TT>`explow.c'</TT>,
<TT>`expmed.c'</TT>,
<TT>`function.c'</TT>,
<TT>`optabs.c'</TT>
and <TT>`emit-rtl.c'</TT>.
Also, the file
<TT>`insn-emit.c'</TT>, generated from the machine description by the
program <CODE>genemit</CODE>, is used in this pass.  The header file
<TT>`expr.h'</TT> is used for communication within this pass.
<A NAME="IDX656"></A>
<A NAME="IDX657"></A>
The header files <TT>`insn-flags.h'</TT> and <TT>`insn-codes.h'</TT>,
generated from the machine description by the programs <CODE>genflags</CODE>
and <CODE>gencodes</CODE>, tell this pass which standard names are available
for use and which patterns correspond to them.
Aside from debugging information output, none of the following passes
refers to the tree structure representation of the function (only
part of which is saved).

<A NAME="IDX658"></A>
The decision of whether the function can and should be expanded inline
in its subsequent callers is made at the end of rtl generation.  The
function must meet certain criteria, currently related to the size of
the function and the types and number of parameters it has.  Note that
this function may contain loops, recursive calls to itself
(tail-recursive functions can be inlined!), gotos, in short, all
constructs supported by GNU CC.  The file <TT>`integrate.c'</TT> contains
the code to save a function's rtl for later inlining and to inline that
rtl when the function is called.  The header file <TT>`integrate.h'</TT>
is also used for this purpose.

The option <SAMP>`-dr'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.rtl'</SAMP> to
the input file name.

<A NAME="IDX659"></A>
<A NAME="IDX660"></A>
<A NAME="IDX661"></A>
<LI>

Jump optimization.  This pass simplifies jumps to the following
instruction, jumps across jumps, and jumps to jumps.  It deletes
unreferenced labels and unreachable code, except that unreachable code
that contains a loop is not recognized as unreachable in this pass.
(Such loops are deleted later in the basic block analysis.)  It also
converts some code originally written with jumps into sequences of
instructions that directly set values from the results of comparisons,
if the machine has such instructions.

Jump optimization is performed two or three times.  The first time is
immediately following RTL generation.  The second time is after CSE,
but only if CSE says repeated jump optimization is needed.  The
last time is right before the final pass.  That time, cross-jumping
and deletion of no-op move instructions are done together with the
optimizations described above.

The source file of this pass is <TT>`jump.c'</TT>.

The option <SAMP>`-dj'</SAMP> causes a debugging dump of the RTL code after
this pass is run for the first time.  This dump file's name is made by
appending <SAMP>`.jump'</SAMP> to the input file name.

<A NAME="IDX662"></A>
<LI>

Register scan.  This pass finds the first and last use of each
register, as a guide for common subexpression elimination.  Its source
is in <TT>`regclass.c'</TT>.

<A NAME="IDX663"></A>
<LI>

Jump threading.  This pass detects a condition jump that branches to an
identical or inverse test.  Such jumps can be <SAMP>`threaded'</SAMP> through
the second conditional test.  The source code for this pass is in
<TT>`jump.c'</TT>.  This optimization is only performed if
<SAMP>`-fthread-jumps'</SAMP> is enabled.

<A NAME="IDX664"></A>
<A NAME="IDX665"></A>
<LI>

Common subexpression elimination.  This pass also does constant
propagation.  Its source file is <TT>`cse.c'</TT>.  If constant
propagation causes conditional jumps to become unconditional or to
become no-ops, jump optimization is run again when CSE is finished.

The option <SAMP>`-ds'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.cse'</SAMP> to
the input file name.

<A NAME="IDX666"></A>
<A NAME="IDX667"></A>
<A NAME="IDX668"></A>
<LI>

Global common subexpression elimination.  This pass performs GCSE
using Morel-Renvoise Partial Redundancy Elimination, with the exception
that it does not try to move invariants out of loops - that is left to
the loop optimization pass.  This pass also performs global constant
and copy propagation.

The source file for this pass is gcse.c.

The option <SAMP>`-dG'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.gcse'</SAMP> to
the input file name.

<A NAME="IDX669"></A>
<A NAME="IDX670"></A>
<A NAME="IDX671"></A>
<LI>

Loop optimization.  This pass moves constant expressions out of loops,
and optionally does strength-reduction and loop unrolling as well.
Its source files are <TT>`loop.c'</TT> and <TT>`unroll.c'</TT>, plus the header
<TT>`loop.h'</TT> used for communication between them.  Loop unrolling uses
some functions in <TT>`integrate.c'</TT> and the header <TT>`integrate.h'</TT>.

The option <SAMP>`-dL'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.loop'</SAMP> to
the input file name.

<LI>

If <SAMP>`-frerun-cse-after-loop'</SAMP> was enabled, a second common
subexpression elimination pass is performed after the loop optimization
pass.  Jump threading is also done again at this time if it was specified.

The option <SAMP>`-dt'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.cse2'</SAMP> to
the input file name.

<A NAME="IDX672"></A>
<A NAME="IDX673"></A>
<LI>

Stupid register allocation is performed at this point in a
nonoptimizing compilation.  It does a little data flow analysis as
well.  When stupid register allocation is in use, the next pass
executed is the reloading pass; the others in between are skipped.
The source file is <TT>`stupid.c'</TT>.

<A NAME="IDX674"></A>
<A NAME="IDX675"></A>
<A NAME="IDX676"></A>
<LI>

Data flow analysis (<TT>`flow.c'</TT>).  This pass divides the program
into basic blocks (and in the process deletes unreachable loops); then
it computes which pseudo-registers are live at each point in the
program, and makes the first instruction that uses a value point at
the instruction that computed the value.

<A NAME="IDX677"></A>
This pass also deletes computations whose results are never used, and
combines memory references with add or subtract instructions to make
autoincrement or autodecrement addressing.

The option <SAMP>`-df'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.flow'</SAMP> to
the input file name.  If stupid register allocation is in use, this
dump file reflects the full results of such allocation.

<A NAME="IDX678"></A>
<LI>

Instruction combination (<TT>`combine.c'</TT>).  This pass attempts to
combine groups of two or three instructions that are related by data
flow into single instructions.  It combines the RTL expressions for
the instructions by substitution, simplifies the result using algebra,
and then attempts to match the result against the machine description.

The option <SAMP>`-dc'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.combine'</SAMP>
to the input file name.

<A NAME="IDX679"></A>
<LI>

Register movement (<TT>`regmove.c'</TT>). This pass looks for cases where
matching constraints would force an instruction to need a reload, and
this reload would be a register to register move.  It them attempts
to change the registers used by the instruction to avoid the move
instruction.

The option <SAMP>`-dN'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.regmove'</SAMP>
to the input file name.

<A NAME="IDX680"></A>
<A NAME="IDX681"></A>
<LI>

Instruction scheduling (<TT>`sched.c'</TT>).  This pass looks for
instructions whose output will not be available by the time that it is
used in subsequent instructions.  (Memory loads and floating point
instructions often have this behavior on RISC machines).  It re-orders
instructions within a basic block to try to separate the definition and
use of items that otherwise would cause pipeline stalls.

Instruction scheduling is performed twice.  The first time is immediately
after instruction combination and the second is immediately after reload.

The option <SAMP>`-dS'</SAMP> causes a debugging dump of the RTL code after this
pass is run for the first time.  The dump file's name is made by
appending <SAMP>`.sched'</SAMP> to the input file name.

<A NAME="IDX682"></A>
<LI>

Register class preferencing.  The RTL code is scanned to find out
which register class is best for each pseudo register.  The source
file is <TT>`regclass.c'</TT>.

<A NAME="IDX683"></A>
<A NAME="IDX684"></A>
<LI>

Local register allocation (<TT>`local-alloc.c'</TT>).  This pass allocates
hard registers to pseudo registers that are used only within one basic
block.  Because the basic block is linear, it can use fast and
powerful techniques to do a very good job.

The option <SAMP>`-dl'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.lreg'</SAMP> to
the input file name.

<A NAME="IDX685"></A>
<LI>

Global register allocation (<TT>`global.c'</TT>).  This pass
allocates hard registers for the remaining pseudo registers (those
whose life spans are not contained in one basic block).

<A NAME="IDX686"></A>
<LI>

Reloading.  This pass renumbers pseudo registers with the hardware
registers numbers they were allocated.  Pseudo registers that did not
get hard registers are replaced with stack slots.  Then it finds
instructions that are invalid because a value has failed to end up in
a register, or has ended up in a register of the wrong kind.  It fixes
up these instructions by reloading the problematical values
temporarily into registers.  Additional instructions are generated to
do the copying.

The reload pass also optionally eliminates the frame pointer and inserts
instructions to save and restore call-clobbered registers around calls.

Source files are <TT>`reload.c'</TT> and <TT>`reload1.c'</TT>, plus the header
<TT>`reload.h'</TT> used for communication between them.

The option <SAMP>`-dg'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.greg'</SAMP> to
the input file name.

<A NAME="IDX687"></A>
<A NAME="IDX688"></A>
<LI>

Instruction scheduling is repeated here to try to avoid pipeline stalls
due to memory loads generated for spilled pseudo registers.

The option <SAMP>`-dR'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.sched2'</SAMP>
to the input file name.

<A NAME="IDX689"></A>
<A NAME="IDX690"></A>
<LI>

Jump optimization is repeated, this time including cross-jumping
and deletion of no-op move instructions.

The option <SAMP>`-dJ'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.jump2'</SAMP>
to the input file name.

<A NAME="IDX691"></A>
<A NAME="IDX692"></A>
<LI>

Delayed branch scheduling.  This optional pass attempts to find
instructions that can go into the delay slots of other instructions,
usually jumps and calls.  The source file name is <TT>`reorg.c'</TT>.

The option <SAMP>`-dd'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.dbr'</SAMP>
to the input file name.

<A NAME="IDX693"></A>
<LI>

Conversion from usage of some hard registers to usage of a register
stack may be done at this point.  Currently, this is supported only
for the floating-point registers of the Intel 80387 coprocessor.   The
source file name is <TT>`reg-stack.c'</TT>.

The options <SAMP>`-dk'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.stack'</SAMP>
to the input file name.

<A NAME="IDX694"></A>
<A NAME="IDX695"></A>
<LI>

Final.  This pass outputs the assembler code for the function.  It is
also responsible for identifying spurious test and compare
instructions.  Machine-specific peephole optimizations are performed
at the same time.  The function entry and exit sequences are generated
directly as assembler code in this pass; they never exist as RTL.

The source files are <TT>`final.c'</TT> plus <TT>`insn-output.c'</TT>; the
latter is generated automatically from the machine description by the
tool <TT>`genoutput'</TT>.  The header file <TT>`conditions.h'</TT> is used
for communication between these files.

<A NAME="IDX696"></A>
<LI>

Debugging information output.  This is run after final because it must
output the stack slot offsets for pseudo registers that did not get
hard registers.  Source files are <TT>`dbxout.c'</TT> for DBX symbol table
format, <TT>`sdbout.c'</TT> for SDB symbol table format, and
<TT>`dwarfout.c'</TT> for DWARF symbol table format.
</UL>

<P>
Some additional files are used by all or many passes:

</P>

<UL>
<LI>

Every pass uses <TT>`machmode.def'</TT> and <TT>`machmode.h'</TT> which define
the machine modes.

<LI>

Several passes use <TT>`real.h'</TT>, which defines the default
representation of floating point constants and how to operate on them.

<LI>

All the passes that work with RTL use the header files <TT>`rtl.h'</TT>
and <TT>`rtl.def'</TT>, and subroutines in file <TT>`rtl.c'</TT>.  The tools
<CODE>gen*</CODE> also use these files to read and work with the machine
description RTL.

<A NAME="IDX697"></A>
<LI>

Several passes refer to the header file <TT>`insn-config.h'</TT> which
contains a few parameters (C macro definitions) generated
automatically from the machine description RTL by the tool
<CODE>genconfig</CODE>.

<A NAME="IDX698"></A>
<LI>

Several passes use the instruction recognizer, which consists of
<TT>`recog.c'</TT> and <TT>`recog.h'</TT>, plus the files <TT>`insn-recog.c'</TT>
and <TT>`insn-extract.c'</TT> that are generated automatically from the
machine description by the tools <TT>`genrecog'</TT> and
<TT>`genextract'</TT>.
<LI>

Several passes use the header files <TT>`regs.h'</TT> which defines the
information recorded about pseudo register usage, and <TT>`basic-block.h'</TT>
which defines the information recorded about basic blocks.

<LI>

<TT>`hard-reg-set.h'</TT> defines the type <CODE>HARD_REG_SET</CODE>, a bit-vector
with a bit for each hard register, and some macros to manipulate it.
This type is just <CODE>int</CODE> if the machine has few enough hard registers;
otherwise it is an array of <CODE>int</CODE> and some of the macros expand
into loops.

<LI>

Several passes use instruction attributes.  A definition of the
attributes defined for a particular machine is in file
<TT>`insn-attr.h'</TT>, which is generated from the machine description by
the program <TT>`genattr'</TT>.  The file <TT>`insn-attrtab.c'</TT> contains
subroutines to obtain the attribute values for insns.  It is generated
from the machine description by the program <TT>`genattrtab'</TT>.</UL>

<P><HR><P>
<p>Go to the <A HREF="gcc_1.html">first</A>, <A HREF="gcc_13.html">previous</A>, <A HREF="gcc_15.html">next</A>, <A HREF="gcc_24.html">last</A> section, <A HREF="gcc_toc.html">table of contents</A>.
</BODY>
</HTML>
